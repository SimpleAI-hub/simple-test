/*
 * Generated Tests
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-10T04:39:40.095Z
 * AI Model: Simple AI V1.0.4
 * Execution Time: 64.85s
 * 
 * ðŸ¤– This file was automatically generated
 * ðŸ”— Visit https://test.smplai.io to generate your own tests
 */

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("SimpleAIToken", function () {
    let SimpleAIToken;
    let simpleAiToken;
    let owner;
    let addr1;
    let addr2;

    beforeEach(async function () {
        [owner, addr1, addr2] = await ethers.getSigners();
        SimpleAIToken = await ethers.getContractFactory("SimpleAIToken");
        simpleAiToken = await SimpleAIToken.deploy();
        await simpleAiToken.waitForDeployment();
    });

    describe("Deployment", function () {
        it("Should set the right owner", async function () {
            expect(await simpleAiToken.owner()).to.equal(owner.getAddress());
        });

        it("Should deploy with correct max supply", async function () {
            expect(await simpleAiToken.totalSupply()).to.equal(ethers.parseUnits("1000000", 18));
        });

        it("Should deploy with correct initial tax rate", async function () {
            expect(await simpleAiToken.taxRate()).to.equal(2);
        });

        it("Should deploy with correct initial tax wallet", async function () {
            expect(await simpleAiToken.taxWallet()).to.equal(owner.getAddress());
        });

        it("Should exclude owner and contract from tax", async function () {
            expect(await simpleAiToken.isExcludedFromTax(owner.getAddress())).to.equal(true);
            expect(await simpleAiToken.isExcludedFromTax(simpleAiToken.getAddress())).to.equal(true);
        });
    });

    describe("Function Tests", function () {
        it("Should transfer with tax deduction", async function () {
            const amount = ethers.parseUnits("100", 18);
            const tx = await simpleAiToken.transfer(addr1.getAddress(), amount);
            const receipt = await tx.wait();
            const transferAmount = amount - (amount * 2) / 100;
            const taxAmount = (amount * 2) / 100;
            expect(await simpleAiToken.balanceOf(addr1.getAddress())).to.equal(transferAmount);
            expect(await simpleAiToken.balanceOf(owner.getAddress())).to.be.closeTo(ethers.parseUnits("1000000", 18) - amount, taxAmount);
            expect(receipt.events.find(e => e.event === 'Transfer')).to.not.be.undefined;
        });

        it("Should transfer without tax for excluded address", async function () {
            await simpleAiToken.excludeFromTax(addr1.getAddress(), true);
            const amount = ethers.parseUnits("100", 18);
            const tx = await simpleAiToken.transfer(addr1.getAddress(), amount);
            const receipt = await tx.wait();
            expect(await simpleAiToken.balanceOf(addr1.getAddress())).to.equal(amount);
            expect(await simpleAiToken.balanceOf(owner.getAddress())).to.equal(ethers.parseUnits("1000000", 18) - amount);
            expect(receipt.events.find(e => e.event === 'Transfer')).to.not.be.undefined;

        });

        it("Should transfer using transferFrom", async function () {
            const amount = ethers.parseUnits("100", 18);
            await simpleAiToken.approve(addr1.getAddress(), amount);
            const tx = await simpleAiToken.connect(addr1).transferFrom(owner.getAddress(), addr2.getAddress(), amount);
            const receipt = await tx.wait();
            const transferAmount = amount - (amount * 2) / 100;
            const taxAmount = (amount * 2) / 100;
            expect(await simpleAiToken.balanceOf(addr2.getAddress())).to.equal(transferAmount);
            expect(await simpleAiToken.balanceOf(owner.getAddress())).to.be.closeTo(ethers.parseUnits("1000000", 18) - amount, taxAmount);
            expect(receipt.events.find(e => e.event === 'Transfer')).to.not.be.undefined;
        });


        it("Should update tax rate", async function () {
            const newTaxRate = 5;
            await simpleAiToken.setTaxRate(newTaxRate);
            expect(await simpleAiToken.taxRate()).to.equal(newTaxRate);
        });

        it("Should update tax wallet", async function () {
            const newTaxWallet = addr1.getAddress();
            await simpleAiToken.setTaxWallet(newTaxWallet);
            expect(await simpleAiToken.taxWallet()).to.equal(newTaxWallet);
        });

        it("Should exclude and include address from tax", async function () {
            await simpleAiToken.excludeFromTax(addr1.getAddress(), true);
            expect(await simpleAiToken.isExcludedFromTax(addr1.getAddress())).to.equal(true);
            await simpleAiToken.excludeFromTax(addr1.getAddress(), false);
            expect(await simpleAiToken.isExcludedFromTax(addr1.getAddress())).to.equal(false);
        });

        it("Should burn tokens", async function () {
            const amount = ethers.parseUnits("100", 18);
            const initialBalance = await simpleAiToken.balanceOf(owner.getAddress());
            await simpleAiToken.burn(amount);
            expect(await simpleAiToken.balanceOf(owner.getAddress())).to.equal(initialBalance - amount);
        });
    });

    describe("Edge Cases", function () {
        it("Should revert if tax rate is too high", async function () {
            await expect(simpleAiToken.setTaxRate(11)).to.be.revertedWith("Tax too high");
        });

        it("Should revert if tax wallet is invalid", async function () {
            await expect(simpleAiToken.setTaxWallet(ethers.ZeroAddress)).to.be.revertedWith("Invalid address");
        });

        it("Should revert if trying to transfer more tokens than balance", async function () {
            const amount = ethers.parseUnits("1000001", 18);
            await expect(simpleAiToken.transfer(addr1.getAddress(), amount)).to.be.reverted;
        });

        it("Should revert if trying to burn more tokens than balance", async function () {
            const amount = ethers.parseUnits("1000001", 18);
            await expect(simpleAiToken.burn(amount)).to.be.reverted;
        });

        it("Should revert if trying to transferFrom without approval", async function () {
            const amount = ethers.parseUnits("100", 18);
            await expect(simpleAiToken.connect(addr1).transferFrom(owner.getAddress(), addr2.getAddress(), amount)).to.be.reverted;
        });

        it("Should revert if trying to transferFrom exceeding allowance", async function () {
            const amount = ethers.parseUnits("100", 18);
            await simpleAiToken.approve(addr1.getAddress(), amount / 2);
            await expect(simpleAiToken.connect(addr1).transferFrom(owner.getAddress(), addr2.getAddress(), amount)).to.be.reverted;
        });

        it("Should handle zero transfer amount", async function () {
            const amount = 0;
            await simpleAiToken.transfer(addr1.getAddress(), amount);
            expect(await simpleAiToken.balanceOf(addr1.getAddress())).to.equal(0);
        });
    });

    describe("Gas Usage", function () {
        it("Should test gas usage for transfer", async function () {
          const amount = ethers.parseUnits("100", 18);
          const tx = await simpleAiToken.transfer(addr1.getAddress(), amount);
          const receipt = await tx.wait();
          console.log("Gas used for transfer:", receipt.gasUsed.toString());
        });

        it("Should test gas usage for transferFrom", async function () {
          const amount = ethers.parseUnits("100", 18);
          await simpleAiToken.approve(addr1.getAddress(), amount);
          const tx = await simpleAiToken.connect(addr1).transferFrom(owner.getAddress(), addr2.getAddress(), amount);
          const receipt = await tx.wait();
          console.log("Gas used for transferFrom:", receipt.gasUsed.toString());
        });
    });

});

```
