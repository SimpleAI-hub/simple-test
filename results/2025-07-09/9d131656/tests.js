/*
 * Generated Tests
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-09T17:40:36.441Z
 * AI Model: gemini-1.5-flash
 * Execution Time: 18.30s
 * 
 * ðŸ¤– This file was automatically generated
 * ðŸ”— Visit https://test.smplai.io to generate your own tests
 */

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("PepeToken", function () {
  let pepeToken;
  let owner;
  let addr1;
  let addr2;
  let addr3;

  beforeEach(async function () {
    [owner, addr1, addr2, addr3] = await ethers.getSigners();
    const PepeToken = await ethers.getContractFactory("PepeToken");
    pepeToken = await PepeToken.deploy(1000000);
    await pepeToken.deployed();
  });

  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await pepeToken.owner()).to.equal(owner.address);
    });
    it("Should have the correct initial supply", async function () {
      expect(await pepeToken.totalSupply()).to.equal(1000000);
    });
    it("Should have correct name and symbol", async function () {
      expect(await pepeToken.name()).to.equal("Pepe");
      expect(await pepeToken.symbol()).to.equal("PEPE");
    });
  });

  describe("Function Tests", function () {
    it("Should allow owner to blacklist an address", async function () {
      await pepeToken.blacklist(addr1.address, true);
      expect(await pepeToken.blacklists(addr1.address)).to.be.true;
    });
    it("Should allow owner to remove from blacklist", async function () {
      await pepeToken.blacklist(addr1.address, true);
      await pepeToken.blacklist(addr1.address, false);
      expect(await pepeToken.blacklists(addr1.address)).to.be.false;
    });
    it("Should allow owner to set rules", async function () {
      await pepeToken.setRule(true, addr3.address, 500000, 1000);
      expect(await pepeToken.limited()).to.be.true;
      expect(await pepeToken.uniswapV2Pair()).to.equal(addr3.address);
      expect(await pepeToken.maxHoldingAmount()).to.equal(500000);
      expect(await pepeToken.minHoldingAmount()).to.equal(1000);
    });
    it("Should allow burning tokens", async function () {
      await pepeToken.transfer(addr1.address, 10000);
      const balanceBefore = await pepeToken.balanceOf(addr1.address);
      await pepeToken.connect(addr1).burn(5000);
      const balanceAfter = await pepeToken.balanceOf(addr1.address);
      expect(balanceAfter).to.equal(balanceBefore - 5000);
    });
    it("Should transfer tokens", async function () {
      await pepeToken.transfer(addr1.address, 50000);
      expect(await pepeToken.balanceOf(addr1.address)).to.equal(50000);
    });
    it("Should approve tokens", async function () {
      await pepeToken.approve(addr2.address, 50000);
      expect(await pepeToken.allowance(owner.address, addr2.address)).to.equal(50000);
    });
    it("Should transferFrom tokens", async function () {
      await pepeToken.approve(addr2.address, 50000);
      await pepeToken.connect(addr2).transferFrom(owner.address, addr1.address, 25000);
      expect(await pepeToken.balanceOf(addr1.address)).to.equal(25000);
    });
  });

  describe("Edge Cases", function () {
    it("Should revert if trying to transfer to blacklisted address", async function () {
      await pepeToken.blacklist(addr1.address, true);
      await expect(pepeToken.transfer(addr1.address, 50000)).to.be.revertedWith("Blacklisted");
    });
    it("Should revert if trying to transfer from blacklisted address", async function () {
      await pepeToken.blacklist(owner.address, true);
      await expect(pepeToken.transfer(addr1.address, 50000)).to.be.revertedWith("Blacklisted");
    });
    it("Should revert if exceeding maxHoldingAmount", async function () {
      await pepeToken.setRule(true, addr3.address, 1000, 100);
      await expect(pepeToken.transfer(addr1.address, 1000000)).to.be.revertedWith("Forbid");
    });
    it("Should revert if below minHoldingAmount", async function () {
        await pepeToken.setRule(true, addr3.address, 1000000, 1000);
        await pepeToken.transfer(addr1, 500);
        await expect(pepeToken.connect(addr1).transfer(addr2, 250)).to.be.revertedWith("Forbid");
    });
    it("Should revert if uniswapV2Pair not set and not owner", async function () {
      await expect(pepeToken.connect(addr1).transfer(addr2, 50000)).to.be.revertedWith("trading is not started");
    });
    it("Should revert if burning more tokens than balance", async function () {
        await expect(pepeToken.connect(addr1).burn(50000)).to.be.reverted;
    });
    it("Should not revert if trading is started and transfer from owner", async function () {
        await pepeToken.setRule(true, addr3.address, 1000000, 100);
        await expect(pepeToken.transfer(addr1.address, 50000)).to.not.be.reverted;
    });

  });
});
```