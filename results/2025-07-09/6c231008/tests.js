/*
 * Generated Tests
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-09T19:17:18.661Z
 * AI Model: gemini-1.5-flash
 * Execution Time: 43.37s
 * 
 * ðŸ¤– This file was automatically generated
 * ðŸ”— Visit https://test.smplai.io to generate your own tests
 */

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("BetterBrokenToken", function () {
  let BetterBrokenToken;
  let betterBrokenToken;
  let owner;
  let addr1;
  let addr2;

  beforeEach(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();
    BetterBrokenToken = await ethers.getContractFactory("BetterBrokenToken");
    betterBrokenToken = await BetterBrokenToken.deploy();
  });

  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await betterBrokenToken.owner()).to.equal(owner.address);
    });

    it("Should assign the total supply of tokens to the owner", async function () {
      const totalSupply = await betterBrokenToken.totalSupply();
      expect(await betterBrokenToken.balanceOf(owner.address)).to.equal(totalSupply);
    });
  });

  describe("Function Tests", function () {
    it("Should transfer tokens between accounts", async function () {
      await betterBrokenToken.transfer(addr1.address, 1000);
      expect(await betterBrokenToken.balanceOf(addr1.address)).to.equal(1000);
    });

    it("Should emit Transfer event on successful transfer", async function () {
      await expect(betterBrokenToken.transfer(addr1.address, 1000))
        .to.emit(betterBrokenToken, "Transfer")
        .withArgs(owner.address, addr1.address, 1000);
    });

    it("Should approve spender to withdraw from owner's account", async function () {
      await betterBrokenToken.approve(addr1.address, 1000);
      expect(await betterBrokenToken.allowance(owner.address, addr1.address)).to.equal(1000);
    });

    it("Should emit Approval event on successful approve", async function () {
      await expect(betterBrokenToken.approve(addr1.address, 1000))
        .to.emit(betterBrokenToken, "Approval")
        .withArgs(owner.address, addr1.address, 1000);
    });

    it("Should transfer tokens from one account to another using allowance", async function () {
      await betterBrokenToken.approve(addr1.address, 1000);
      await betterBrokenToken.transferFrom(owner.address, addr2.address, 500);
      expect(await betterBrokenToken.balanceOf(addr2.address)).to.equal(500);
    });

    it("Should emit Transfer event on successful transferFrom", async function () {
      await betterBrokenToken.approve(addr1.address, 1000);
      await expect(betterBrokenToken.connect(addr1).transferFrom(owner.address, addr2.address, 500))
        .to.emit(betterBrokenToken, "Transfer")
        .withArgs(owner.address, addr2.address, 500);
    });

    it("Should mint tokens", async function () {
      await betterBrokenToken.mint(addr1.address, 1000);
      expect(await betterBrokenToken.balanceOf(addr1.address)).to.equal(1000);
    });

    it("Should emit Transfer event on successful mint", async function () {
      await expect(betterBrokenToken.mint(addr1.address, 1000))
        .to.emit(betterBrokenToken, "Transfer")
        .withArgs(ethers.constants.AddressZero, addr1.address, 1000);
    });

    it("Should set a new owner", async function () {
      await betterBrokenToken.setOwner(addr1.address);
      expect(await betterBrokenToken.owner()).to.equal(addr1.address);
    });
  });

  describe("Edge Cases", function () {
    it("Should revert when transferring zero tokens", async function () {
      await expect(betterBrokenToken.transfer(addr1.address, 0)).to.be.revertedWith("Transfer amount must be greater than zero");
    });

    it("Should revert when transferring more tokens than balance", async function () {
      await expect(betterBrokenToken.transfer(addr1.address, 1000000000 * 10**18 + 1)).to.be.reverted;
    });

    it("Should revert when transferring from an account with insufficient allowance", async function () {
      await expect(betterBrokenToken.connect(addr1).transferFrom(owner.address, addr2.address, 1000)).to.be.revertedWith("Insufficient allowance");
    });

    it("Should not decrease allowance after transferFrom", async function(){
        await betterBrokenToken.approve(addr1.address, 1000);
        await betterBrokenToken.connect(addr1).transferFrom(owner.address, addr2.address, 500);
        expect(await betterBrokenToken.allowance(owner.address, addr1.address)).to.equal(1000);
    })
  });


  describe("Gas Usage", function(){
    it("Should measure gas usage for transfer", async function(){
        const tx = await betterBrokenToken.transfer(addr1.address, 1000);
        const receipt = await tx.wait();
        console.log("Gas used for transfer:", receipt.gasUsed.toString());
    })

    it("Should measure gas usage for approve", async function(){
        const tx = await betterBrokenToken.approve(addr1.address, 1000);
        const receipt = await tx.wait();
        console.log("Gas used for approve:", receipt.gasUsed.toString());
    })

    it("Should measure gas usage for transferFrom", async function(){
        await betterBrokenToken.approve(addr1.address, 1000);
        const tx = await betterBrokenToken.connect(addr1).transferFrom(owner.address, addr2.address, 500);
        const receipt = await tx.wait();
        console.log("Gas used for transferFrom:", receipt.gasUsed.toString());
    })

    it("Should measure gas usage for mint", async function(){
        const tx = await betterBrokenToken.mint(addr1.address, 1000);
        const receipt = await tx.wait();
        console.log("Gas used for mint:", receipt.gasUsed.toString());
    })
  })
});
```
