/*
 * Generated Tests
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-09T20:01:12.551Z
 * AI Model: gemini-1.5-flash
 * Execution Time: 16.95s
 * 
 * ðŸ¤– This file was automatically generated
 * ðŸ”— Visit https://test.smplai.io to generate your own tests
 */

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("KIBI", function () {
  let kibi;
  let owner;
  let addr1;
  let addr2;
  let uniswapV2Router;

  beforeEach(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();
    const KIBI = await ethers.getContractFactory("KIBI");
    kibi = await KIBI.deploy();
    await kibi.deployed();
  });

  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await kibi.owner()).to.equal(owner.address);
    });
    it("Should have correct totalSupply", async function () {
      expect(await kibi.totalSupply()).to.equal(100000000000 * 10**9);
    });
  });

  describe("Function Tests", function () {
    beforeEach(async function () {
      await kibi.openTrading();
      uniswapV2Router = await ethers.getContractAt("IUniswapV2Router02", "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D");
    });
    it("Transfer should emit Transfer event", async function () {
      await expect(kibi.transfer(addr1.address, 1000))
        .to.emit(kibi, "Transfer")
        .withArgs(owner.address, addr1.address, 1000);
    });

    it("Approve should emit Approval event", async function () {
      await expect(kibi.approve(addr1.address, 1000))
        .to.emit(kibi, "Approval")
        .withArgs(owner.address, addr1.address, 1000);
    });

    it("TransferFrom should emit Transfer event", async function () {
      await kibi.approve(addr1.address, 1000);
      await expect(kibi.transferFrom(owner.address, addr2.address, 1000))
        .to.emit(kibi, "Transfer")
        .withArgs(owner.address, addr2.address, 1000);
    });

    it("should allow owner to renounceOwnership", async function () {
      await kibi.renounceOwnership();
      expect(await kibi.owner()).to.equal(ethers.constants.AddressZero);
    });

    it("should allow owner to remove limits", async function () {
      await kibi.removeLimits();
      expect(await kibi._maxTxAmount).to.equal(100000000000 * 10**9);
      expect(await kibi._maxWalletSize).to.equal(100000000000 * 10**9);
    });

    it("should allow taxWallet to perform manualSwap", async function () {
      await kibi.transfer(addr1.address, 1000);
      await kibi.connect(addr1).transfer(kibi.address, 500);
      await kibi.connect(owner).manualSwap();
      expect(await ethers.provider.getBalance(await kibi._taxWallet())).to.be.gt(0);
    });

    it("should allow taxWallet to perform manualsend", async function () {
      await kibi.connect(owner).manualsend();
      expect(await ethers.provider.getBalance(await kibi._taxWallet())).to.be.gt(0);
    });
  });

  describe("Edge Cases", function () {
    it("Should revert transfer with zero amount", async function () {
      await expect(kibi.transfer(addr1.address, 0)).to.be.revertedWith("Transfer amount must be greater than zero");
    });

    it("Should revert transfer to zero address", async function () {
      await expect(kibi.transfer(ethers.constants.AddressZero, 1000)).to.be.revertedWith("ERC20: transfer to the zero address");
    });

    it("Should revert transfer from zero address", async function () {
      await expect(kibi.connect(ethers.constants.AddressZero).transfer(addr1.address, 1000)).to.be.reverted;
    });

    it("Should revert approve to zero address", async function () {
      await expect(kibi.approve(ethers.constants.AddressZero, 1000)).to.be.revertedWith("ERC20: approve to the zero address");
    });

    it("Should revert approve from zero address", async function () {
      await expect(kibi.connect(ethers.constants.AddressZero).approve(addr1.address, 1000)).to.be.reverted;
    });

    it("Should revert transferFrom with insufficient allowance", async function () {
      await expect(kibi.transferFrom(owner.address, addr2.address, 1000)).to.be.reverted;
    });

    it("Should revert transfer exceeding maxTxAmount", async function () {
      await kibi.openTrading();
      await expect(kibi.transfer(addr1.address, (await kibi._maxTxAmount).add(1))).to.be.revertedWith("Exceeds the _maxTxAmount.");
    });

    it("Should revert transfer exceeding maxWalletSize", async function () {
      await kibi.openTrading();
      await expect(kibi.transfer(addr1.address, (await kibi._maxWalletSize).add(1))).to.be.revertedWith("Exceeds the maxWalletSize.");
    });


    it("Should revert manualSwap if not taxWallet", async function () {
      await expect(kibi.manualSwap()).to.be.reverted;
    });

    it("Should revert manualsend if not taxWallet", async function () {
      await expect(kibi.manualsend()).to.be.reverted;
    });

    it("Should revert openTrading if already open", async function () {
        await kibi.openTrading();
        await expect(kibi.openTrading()).to.be.revertedWith("trading is already open");
    });

  });
});
```