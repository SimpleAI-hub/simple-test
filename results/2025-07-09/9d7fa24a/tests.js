/*
 * Generated Tests
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-09T20:12:09.087Z
 * AI Model: gemini-1.5-flash
 * Execution Time: 46.25s
 * 
 * ðŸ¤– This file was automatically generated
 * ðŸ”— Visit https://test.smplai.io to generate your own tests
 */

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("AgenticStudio", function () {
  let contract;
  let owner;
  let addr1;
  let addr2;
  let treasury;
  const maxSupply = ethers.utils.parseEther("1000000");
  const swapThreshold = maxSupply.div(5000);

  beforeEach(async function () {
    [owner, addr1, addr2, treasury] = await ethers.getSigners();
    const AgenticStudio = await ethers.getContractFactory("AgenticStudio");
    contract = await AgenticStudio.deploy("Agentic Studio", "AGS", maxSupply, treasury.address);
    await contract.deployed();
  });

  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await contract.owner()).to.equal(owner.address);
    });
    it("Should set the correct max supply", async function () {
      expect(await contract.MAX_SUPPLY()).to.equal(maxSupply);
    });
    it("Should set the correct swap threshold", async function () {
      expect(await contract.SWAP_THRESHOLD()).to.equal(swapThreshold);
    });
    it("Should set the treasury address correctly", async function () {
      expect(await contract.treasury()).to.equal(treasury.address);
    });
    it("Should mint the max supply to the deployer", async function () {
      expect(await contract.balanceOf(owner.address)).to.equal(maxSupply);
    });

  });

  describe("Function Tests", function () {
    it("Should allow the owner to set the treasury", async function () {
      await contract.setTreasury(addr1.address);
      expect(await contract.treasury()).to.equal(addr1.address);
    });
    it("Should allow the owner to enable trading", async function () {
      await contract.enableTrading();
      expect(await contract.startBlock()).to.be.gt(0);
    });
    it("Should allow the owner to set excluded addresses from fees", async function () {
      await contract.setExcludedFromFees(addr1.address, true);
      expect(await contract.isExcludedFromFees(addr1.address)).to.be.true;
    });
    it("Should allow the owner to set excluded addresses from max wallet", async function () {
      await contract.setExcludedFromMaxWallet(addr1.address, true);
      expect(await contract.isExcludedFromMaxWallet(addr1.address)).to.be.true;
    });
    it("Should transfer tokens correctly after enabling trading", async function () {
      await contract.enableTrading();
      await contract.transfer(addr1.address, maxSupply.div(100));
      expect(await contract.balanceOf(addr1.address)).to.equal(maxSupply.div(100));
    });
    it("Should emit Transfer events on transfer", async function () {
      await contract.enableTrading();
      await expect(contract.transfer(addr1.address, maxSupply.div(100)))
        .to.emit(contract, "Transfer")
        .withArgs(owner.address, addr1.address, maxSupply.div(100));
    });

  });

  describe("Edge Cases", function () {
    it("Should revert if enabling trading twice", async function () {
      await contract.enableTrading();
      await expect(contract.enableTrading()).to.be.revertedWith("Already enabled");
    });
    it("Should revert if transferring more than balance", async function () {
      await expect(contract.transfer(addr1.address, maxSupply.add(1))).to.be.reverted;
    });
    it("Should revert if transferring to zero address", async function () {
      await expect(contract.transfer(ethers.constants.AddressZero, 1)).to.be.reverted;
    });
    it("Should handle max buy txs per block", async function () {
      await contract.enableTrading();
      for (let i = 0; i < 10; i++) {
        await contract.connect(addr1).transferFrom(owner.address, addr1.address, maxSupply.div(1000));
      }
      await expect(contract.connect(addr1).transferFrom(owner.address, addr1.address, maxSupply.div(1000))).to.be.revertedWith("Max buy txs per block for origin");
    });
    it("Should handle max wallet limit", async function () {
      await contract.enableTrading();
      const maxWallet = await contract.feesAndMaxWallet();
      await expect(contract.transfer(addr1.address, maxWallet[1].add(1))).to.be.revertedWith("Max wallet");
    });
    it("Should handle fees and max wallet limits correctly during different timeframes", async function () {
      await contract.enableTrading();
      let feesAndMaxWallet;
      feesAndMaxWallet = await contract.feesAndMaxWallet();
      expect(feesAndMaxWallet[0]).to.be.gt(0);
      expect(feesAndMaxWallet[1]).to.be.lt(maxSupply);
      await ethers.provider.send("evm_increaseTime", [1441]);
      await ethers.provider.send("evm_mine");
      feesAndMaxWallet = await contract.feesAndMaxWallet();
      expect(feesAndMaxWallet[0]).to.be.eq(400);
      expect(feesAndMaxWallet[1]).to.be.eq(maxSupply);
    });
    it("Should swap tokens to treasury after reaching swap threshold and time condition", async function () {
      await contract.enableTrading();
      await ethers.provider.send("evm_increaseTime", [301]);
      await ethers.provider.send("evm_mine");
      await contract.transfer(addr1.address, maxSupply.sub(swapThreshold.mul(2)));
      expect(await contract.balanceOf(treasury.address)).to.be.gt(0);
    });
  });
});

```
