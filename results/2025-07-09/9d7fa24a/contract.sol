/*
 * Solidity Contract
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-09T20:12:09.087Z
 * AI Model: gemini-1.5-flash
 * Execution Time: 46.25s
 * 
 * ðŸ¤– This file was automatically generated
 * ðŸ”— Visit https://test.smplai.io to generate your own tests
 */

// SPDX-License-Identifier: MIT
/*

 _______                   __   __          _______ __            __ __       
|   _   .-----.-----.-----|  |_|__.----.   |   _   |  |_.--.--.--|  |__.-----.
|.  A   |  _  |  -__|     |   _|  |  __|   |   S___|   _|  |  |  _  |  |  _  |
|.  _   |___  |_____|__|__|____|__|____|   |____   |____|_____|_____|__|_____|
|:  |   |_____|                            |:  |   |                          
|::.|:. |                                  |::.. . |                          
`--- ---'                                  `-------'                         

* AI agents that build games.
* Design stages, create cinematics, and construct worlds with AI.
* Low/no code, prompt-driven, web3-friendly.

Copyright (c) 2025 Agentic Studio

https://agenticstudio.online
https://x.com/studioagentic
https://t.me/agenticstudioportal
https://docs.agenticstudio.online/

*/

pragma solidity ^0.8.28;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./IUniswapV2Router02.sol";

interface IFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

contract AgenticStudio is ERC20, Ownable {
    uint256 public immutable MAX_SUPPLY;
    uint256 public immutable SWAP_THRESHOLD;
    address public immutable pair;
    address public treasury;

    IUniswapV2Router02 private constant _router =
        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    address private immutable _weth;
    address private immutable _deployer;

    uint256 public startBlock;
    uint256 public startBlockTime;
    uint256 public raisedAmount;

    mapping(address account => bool) public isExcludedFromFees;
    mapping(address account => bool) public isExcludedFromMaxWallet;
    mapping(address origin => mapping(uint256 blockNumber => uint256 txCount)) public maxBuyTxsPerBlockPerOrigin;
    uint256 private _maxBuyTxsPerBlockPerOrigin = 10;
    mapping(uint256 blockNumber => uint256 txCount) public maxBuyTxsPerBlock;
    uint256 private _maxBuyTxsPerBlock = 100;

    constructor(
        string memory name,
        string memory symbol,
        uint256 maxSupply,
        address _treasury
    ) ERC20(name, symbol) Ownable(msg.sender) {
        MAX_SUPPLY = maxSupply;
        SWAP_THRESHOLD = maxSupply / 5000; // collected fee is swappable after 0.02% of total supply is reached
        
        _weth = _router.WETH();

        pair = IFactory(_router.factory()).createPair(
            address(this),
            _weth
        );

        isExcludedFromFees[msg.sender] = true;
        isExcludedFromFees[address(this)] = true;
        isExcludedFromFees[pair] = true;
        isExcludedFromFees[treasury] = true;
        isExcludedFromMaxWallet[msg.sender] = true;
        isExcludedFromMaxWallet[address(this)] = true;
        isExcludedFromMaxWallet[pair] = true;
        isExcludedFromMaxWallet[treasury] = true;

        _mint(msg.sender, maxSupply);
        _approve(msg.sender, address(_router), type(uint256).max);

        treasury = _treasury;
        _deployer = msg.sender;
        _approve(address(this), address(_router), type(uint256).max);
    }

    function setTreasury(address newTreasury) external onlyOwner {
        treasury = newTreasury;
    }

    function enableTrading() external onlyOwner {
        require(startBlock == 0, "Already enabled");
        startBlock = block.number;
        startBlockTime = block.timestamp;
    }

    function setExcludedFromFees(
        address account,
        bool excluded
    ) external onlyOwner {
        isExcludedFromFees[account] = excluded;
    }

    function setExcludedFromMaxWallet(
        address account,
        bool excluded
    ) external onlyOwner {
        isExcludedFromMaxWallet[account] = excluded;
    }

    function feesAndMaxWallet()
        external
        view
        returns (uint256 _feeBps, uint256 _maxWallet)
    {
        return _feesAndMaxWallet();
    }

    function _feesAndMaxWallet()
        internal
        view
        returns (uint256 _feeBps, uint256 _maxWallet)
    {
        if (startBlockTime == 0) {
            return (0, 0);
        }

        uint256 _diffSeconds = block.timestamp - startBlockTime;
        
        // first 24 minutes
        if (_diffSeconds < 1440) {
            // first 4 min
            if (_diffSeconds < 240) {
                _feeBps = 2000; // 20%
                _maxWallet = MAX_SUPPLY / 64;
            } 
            // [4, 8) min
            else if (_diffSeconds < 480) {             
                _feeBps = 1600; // 16%
                _maxWallet = MAX_SUPPLY / 48;
            }
            // [8, 24) min
            else {
                _feeBps = 800; // 8%;
                _maxWallet = MAX_SUPPLY / 32;
            }

            return (_feeBps, _maxWallet);
        }

        // remove fees after raised amount reaches 1300 ether
        if (raisedAmount < 1300 ether) {
            _feeBps = 400; // 4%;
        } else {
            _feeBps = 0; // 0%;
        }
        
        _maxWallet = MAX_SUPPLY; // no limit
        return (_feeBps, _maxWallet);
    }

    function _update(
        address from,
        address to,
        uint256 value
    ) internal override {
        (uint256 _feeBps, uint256 _maxWallet) = _feesAndMaxWallet();

        bool isBuy = from == pair;
        if (isBuy || to == pair) {
            require(
                startBlock > 0 || isExcludedFromFees[to],
                "Not yet enabled"
            );

            if (_feeBps != 0) {
                if (isBuy && !isExcludedFromFees[to]) {
                    if (
                        startBlockTime > 0 &&
                        block.timestamp - startBlockTime < 180
                    ) {
                        require(
                            maxBuyTxsPerBlockPerOrigin[tx.origin][
                                block.number
                            ] < _maxBuyTxsPerBlockPerOrigin,
                            "Max buy txs per block for origin"
                        );
                        maxBuyTxsPerBlockPerOrigin[tx.origin][block.number]++;

                        require(
                            maxBuyTxsPerBlock[block.number] <
                                _maxBuyTxsPerBlock,
                            "Max buy txs per block"
                        );
                        maxBuyTxsPerBlock[block.number]++;
                    }

                    uint256 fee = (value * _feeBps) / 10000;
                    value -= fee;
                    super._update(from, address(this), fee);
                }

                if (!isBuy && !isExcludedFromFees[from]) {
                    uint256 fee = (value * _feeBps) / 10000;
                    value -= fee;
                    super._update(from, address(this), fee);
                    _swap();
                }
            } else {
                // sell remaining tokens after raise-cap is reached
                if (!isBuy && !isExcludedFromFees[from]) {
                    _swap();
                }
            }
        }

        require(
            isExcludedFromMaxWallet[to] || value + balanceOf(to) <= _maxWallet,
            "Max wallet"
        );
        
        super._update(from, to, value);
    }

    function _swap() internal {
        uint256 startDiff = block.timestamp - startBlockTime;
        
        // no swap in the first 5 minutes
        if (startDiff < 300) {
            return;
        }

        uint256 _tokenAmount = balanceOf(address(this));

        // no swap for less than 0.02% of total supply
        if (_tokenAmount < SWAP_THRESHOLD) {
            return;
        }

        address[] memory _path = new address[](2);
        _path[0] = address(this);
        _path[1] = _weth;

        uint256 _treasuryBalanceBefore = address(treasury).balance;

        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _tokenAmount,
            0,
            _path,
            treasury,
            block.timestamp
        );

        uint256 _treasuryBalanceAfter = address(treasury).balance;
        raisedAmount += _treasuryBalanceAfter - _treasuryBalanceBefore;
    }
}