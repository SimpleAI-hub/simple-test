/*
 * Generated Tests
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-09T20:09:16.130Z
 * AI Model: gemini-1.5-flash
 * Execution Time: 23.01s
 * 
 * ðŸ¤– This file was automatically generated
 * ðŸ”— Visit https://test.smplai.io to generate your own tests
 */

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { BigNumber } = require("ethers");

describe("DePiggyBank", function () {
  let dePiggyBank;
  let owner;
  let addr1;
  let addr2;
  let usdt;
  let usdc;
  let tbtc;

  beforeEach(async function () {
    [owner, addr1, addr2, ...addrs] = await ethers.getSigners();
    const DePiggyBank = await ethers.getContractFactory("DePiggyBank");
    dePiggyBank = await DePiggyBank.deploy(owner.address);
    await dePiggyBank.deployed();
    await dePiggyBank.initializeOracle();

    const USDT = await ethers.getContractFactory("MockUSDT");
    usdt = await USDT.deploy();
    await usdt.deployed();

    const USDC = await ethers.getContractFactory("MockUSDC");
    usdc = await USDC.deploy();
    await usdc.deployed();

    const TBTC = await ethers.getContractFactory("MockTBTC");
    tbtc = await TBTC.deploy();
    await tbtc.deployed();

    await dePiggyBank.setSupportedStablecoin(usdt.address, true);
    await dePiggyBank.setSupportedStablecoin(usdc.address, true);
  });

  describe("Deployment", function () {
    it("Should set the right founder", async function () {
      expect(await dePiggyBank.founder()).to.equal(owner.address);
    });
  });

  describe("Function Tests", function () {
    it("Should set a goal", async function () {
      await dePiggyBank.setGoal(100e6);
      expect(await dePiggyBank.userGoals(addr1.address)).to.not.be.empty;
      expect(await dePiggyBank.userGoals(addr1.address).targetAmount).to.equal(100e6);
    });

    it("Should deposit funds", async function () {
      await dePiggyBank.setGoal(100e6);
      await usdt.mint(addr1.address, ethers.utils.parseUnits("100", 6));
      await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("100", 6));
      const tx = await dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("100", 6), 0);
      await tx.wait();
      expect(await dePiggyBank.userGoals(addr1.address).tbtcBalance).to.be.gt(0);
    });

    it("Should request early withdraw", async function () {
      await dePiggyBank.setGoal(100e6);
      await usdt.mint(addr1.address, ethers.utils.parseUnits("100", 6));
      await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("100", 6));
      await dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("100", 6), 0);
      await dePiggyBank.requestEarlyWithdraw();
      expect((await dePiggyBank.userGoals(addr1.address)).withdrawRequestTime).to.be.gt(0);
    });

    it("Should withdraw when goal is reached", async function () {
      await dePiggyBank.setGoal(100e6);
      await usdt.mint(addr1.address, ethers.utils.parseUnits("10000", 6));
      await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("10000", 6));
      await dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("10000", 6), 0);
      await dePiggyBank.withdrawGoalReached();
      expect(await dePiggyBank.userGoals(addr1.address).tbtcBalance).to.equal(0);
    });

    it("Should handle founder change", async function () {
      await dePiggyBank.requestFounderChange(addr1.address);
      await dePiggyBank.connect(addr1).acceptFounderChange();
      expect(await dePiggyBank.founder()).to.equal(addr1.address);
    });
  });

  describe("Edge Cases", function () {
    it("Should revert if deposit is below minimum", async function () {
      await dePiggyBank.setGoal(100e6);
      await expect(dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("9", 6), 0)).to.be.revertedWith("Below minimum deposit");
    });

    it("Should revert if goal is not set", async function () {
      await expect(dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("100", 6), 0)).to.be.revertedWith("No active goal");
    });

    it("Should handle emergency withdrawal", async function () {
      await dePiggyBank.setGoal(100e6);
      await usdt.mint(addr1.address, ethers.utils.parseUnits("100", 6));
      await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("100", 6));
      await dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("100", 6), 0);
      // Simulate oracle failure
      await ethers.provider.send("evm_increaseTime", [dePiggyBank.ORACLE_TIMEOUT() + 1]);
      await dePiggyBank.emergencyWithdraw();
      expect(await dePiggyBank.userGoals(addr1.address).tbtcBalance).to.equal(0);
    });

    it("Should handle increase goal after goal reached", async function () {
        await dePiggyBank.setGoal(100e6);
        await usdt.mint(addr1.address, ethers.utils.parseUnits("10000", 6));
        await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("10000", 6));
        await dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("10000", 6), 0);
        await dePiggyBank.increaseGoal(200e6);
        expect(await dePiggyBank.userGoals(addr1.address).targetAmount).to.equal(200e6);
    });

    it("Should handle partial withdraw", async function() {
        await dePiggyBank.setGoal(100e6);
        await usdt.mint(addr1.address, ethers.utils.parseUnits("1000", 6));
        await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("1000", 6));
        await dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("1000", 6), 0);
        await dePiggyBank.requestEarlyWithdraw();
        await ethers.provider.send("evm_increaseTime", [dePiggyBank.WITHDRAW_DELAY() + 1]);
        await dePiggyBank.executePartialEarlyWithdraw(50);
        expect(await dePiggyBank.userGoals(addr1.address).tbtcBalance).to.be.gt(0);
    });

    it("Should handle insufficient slippage protection", async function() {
        await dePiggyBank.setGoal(100e6);
        await usdt.mint(addr1.address, ethers.utils.parseUnits("1000", 6));
        await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("1000", 6));
        const minTBTCOut = await dePiggyBank.getMinTBTCOut(usdt.address, ethers.utils.parseUnits("1000", 6));
        await expect(dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("1000", 6), minTBTCOut.sub(1))).to.be.revertedWith("minTBTCOut too low - insufficient slippage protection");
    });


  });

  describe("Gas Usage", function () {
    it("Should measure gas usage for deposit", async function () {
      await dePiggyBank.setGoal(100e6);
      await usdt.mint(addr1.address, ethers.utils.parseUnits("100", 6));
      await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("100", 6));
      const tx = await dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("100", 6), 0);
      const receipt = await tx.wait();
      console.log("Gas used for deposit:", receipt.gasUsed.toString());
    });
  });

  describe("Events", function () {
    it("Should emit GoalSet event", async function () {
      await expect(dePiggyBank.setGoal(100e6))
        .to.emit(dePiggyBank, "GoalSet")
        .withArgs(addr1.address, 100e6);
    });

    it("Should emit Deposited event", async function () {
      await dePiggyBank.setGoal(100e6);
      await usdt.mint(addr1.address, ethers.utils.parseUnits("100", 6));
      await usdt.approve(dePiggyBank.address, ethers.utils.parseUnits("100", 6));
      await expect(dePiggyBank.deposit(usdt.address, ethers.utils.parseUnits("100", 6), 0))
        .to.emit(dePiggyBank, "Deposited");
    });
  });
});
```