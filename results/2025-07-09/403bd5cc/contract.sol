/*
 * Solidity Contract
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-09T20:09:16.130Z
 * AI Model: gemini-1.5-flash
 * Execution Time: 23.01s
 * 
 * ü§ñ This file was automatically generated
 * üîó Visit https://test.smplai.io to generate your own tests
 */

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";

contract DePiggyBank is ReentrancyGuard {
    using SafeERC20 for IERC20;

    // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —Ü–µ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    struct UserGoal {
        uint256 targetAmount;        // –¶–µ–ª–µ–≤–∞—è —Å—É–º–º–∞ –≤ USD (6 decimals)
        uint256 tbtcBalance;         // –ù–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–π TBTC (18 decimals)
        address lastDepositToken;    // –ü–æ—Å–ª–µ–¥–Ω–∏–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω
        bool goalReached;            // –î–æ—Å—Ç–∏–≥–Ω—É—Ç–∞ –ª–∏ —Ü–µ–ª—å (101%)
        uint256 withdrawRequestTime; // –í—Ä–µ–º—è –∑–∞—è–≤–∫–∏ –Ω–∞ –¥–æ—Å—Ä–æ—á–Ω—ã–π –≤—ã–≤–æ–¥
        bool hasActiveGoal;          // –ï—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω–∞—è —Ü–µ–ª—å
        uint256 totalDepositsUSD;    // –û–±—â–∞—è —Å—É–º–º–∞ –¥–µ–ø–æ–∑–∏—Ç–æ–≤ –≤ USD –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –¥–æ–ª–µ–π
        bool hasReached101Percent;   // Historical tracking of 101% achievement
        uint256 highestPercentage;   // Track highest percentage reached
    }

    // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –∫–∞—Å–∫–∞–¥–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
    struct CascadeUser {
        address user;
        uint256 goalId;
        uint256 percentage;
    }

    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
    uint256 public constant DEPOSIT_FEE_BPS = 10;        // 0.1% = 10 –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–æ–≤
    uint256 public constant GOAL_FEE_BPS = 100;          // 1% = 100 –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–æ–≤
    uint256 public constant GOAL_THRESHOLD_BPS = 10100;  // 101% = 10100 –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–æ–≤
    uint256 public constant CASCADE_THRESHOLD_BPS = 10500; // 105% = 10500 –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–æ–≤
    uint256 public constant CASCADE_BONUS_BPS = 300;     // 3% = 300 –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–æ–≤
    uint256 public constant EMERGENCY_FEE_BPS = 10;      // 0.1% = 10 –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–æ–≤
    uint256 public constant MIN_DEPOSIT_USD = 10e6;      // $10 —Å 6 decimals
    uint256 public constant WITHDRAW_DELAY = 30 days;    // 30 –¥–Ω–µ–π –∑–∞–¥–µ—Ä–∂–∫–∞
    uint256 public constant ORACLE_TIMEOUT = 30 days;    // 30 –¥–Ω–µ–π —Ç–∞–π–º–∞—É—Ç –æ—Ä–∞–∫—É–ª–∞
    uint24 public constant POOL_FEE = 3000;              // 0.3% –∫–æ–º–∏—Å—Å–∏—è –ø—É–ª–∞ Uniswap
    uint256 public constant MAX_SLIPPAGE_BPS = 300;      // 3% –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π slippage
    uint256 public constant MIN_PARTIAL_WITHDRAW_PERCENT = 10; // –ú–∏–Ω–∏–º—É–º 10% –¥–ª—è —á–∞—Å—Ç–∏—á–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞
    uint256 public constant MAX_CASCADE_BATCH = 25;      // Maximum users to process in one cascade batch

    // –ê–¥—Ä–µ—Å–∞ —Ç–æ–∫–µ–Ω–æ–≤ –Ω–∞ Ethereum mainnet
    address public constant TBTC = 0x18084fbA666a33d37592fA2633fD49a74DD93a88; // TBTC mainnet address
    address public constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant USDS = 0xdC035D45d973E3EC169d2276DDab16f1e407384F;
    address public constant LUSD = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH for routing
    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC for routing
    
    // –ê–¥—Ä–µ—Å–∞ Chainlink price feeds
    address public constant BTC_USD_FEED = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c; // BTC/USD mainnet feed
    
    // Uniswap V3 Router
    ISwapRouter public constant SWAP_ROUTER = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564); // Mainnet router

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
    address public founder;  // Changed from immutable to allow founder changes
    address public pendingFounder;
    uint256 public lastOracleUpdate;
    uint256 public totalTBTCInContract;
    uint256 public totalDepositsInUSD;
    mapping(address => UserGoal) public userGoals;
    mapping(address => bool) public supportedStablecoins;
    
    // Cascade system state
    address[] public cascadeQueue;
    mapping(address => bool) public inCascadeQueue;
    bool public cascadePaused;
    uint256 public cascadeProcessedCount;

    // –°–æ–±—ã—Ç–∏—è
    event GoalSet(address indexed user, uint256 targetAmount);
    event GoalIncreased(address indexed user, uint256 oldTarget, uint256 newTarget);
    event Deposited(address indexed user, address token, uint256 amount, uint256 tbtcReceived, uint256 founderFee);
    event WithdrawRequested(address indexed user, uint256 timestamp);
    event WithdrawRequestCancelled(address indexed user);
    event PartialWithdrawnEarly(address indexed user, uint256 percent, uint256 tbtcAmount, address token, uint256 usdAmount);
    event WithdrawnEarly(address indexed user, uint256 tbtcAmount, address token, uint256 usdAmount);
    event GoalReached(address indexed user, uint256 tbtcAmount, address token, uint256 usdAmount);
    event FounderFeeCollected(address indexed founder, uint256 amount, address token);
    event FounderChanged(address indexed oldFounder, address indexed newFounder);
    event FounderChangeRequested(address indexed currentFounder, address indexed pendingFounder);
    event OracleUpdated(uint256 timestamp, int256 price);
    event EmergencyModeActivated(uint256 timestamp);
    event EmergencyWithdrawal(address indexed user, uint256 tbtcAmount, uint256 founderFee);
    event SwapExecuted(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);
    event GoalQualified(address indexed user, uint256 percentage);
    event CascadeTriggered(address indexed trigger, uint256 totalUsers);
    event CascadeProcessed(uint256 usersProcessed, uint256 remaining);
    event CascadePausedToggled(bool paused);

    modifier updateOracle() {
        _updateOraclePrice();
        _;
    }

    constructor(address _founder) {
        require(_founder != address(0), "Invalid founder");
        founder = _founder;
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤
        supportedStablecoins[USDT] = true;
        supportedStablecoins[USDC] = true;
        supportedStablecoins[DAI] = true;
        supportedStablecoins[USDS] = true;
        supportedStablecoins[LUSD] = true;
        
        // Set initial timestamp to prevent immediate emergency mode
        lastOracleUpdate = block.timestamp;
    }

    // Initialize oracle after deployment (for production)
    function initializeOracle() external {
        require(msg.sender == founder, "Only founder");
        _updateOraclePrice();
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω—ã –æ—Ä–∞–∫—É–ª–∞
    function _updateOraclePrice() private {
        try AggregatorV3Interface(BTC_USD_FEED).latestRoundData() returns (
            uint80,
            int256 price,
            uint256,
            uint256 updatedAt,
            uint80
        ) {
            if (price > 0 && updatedAt > 0) {
                lastOracleUpdate = block.timestamp;
                emit OracleUpdated(block.timestamp, price);
            }
        } catch {
            // –û—Ä–∞–∫—É–ª –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–π–º–∞—É—Ç
            if (block.timestamp > lastOracleUpdate + ORACLE_TIMEOUT) {
                emit EmergencyModeActivated(block.timestamp);
            }
        }
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤–∞—Ä–∏–π–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
    function isEmergencyMode() public view returns (bool) {
        return block.timestamp > lastOracleUpdate + ORACLE_TIMEOUT;
    }

    // –ê–≤–∞—Ä–∏–π–Ω—ã–π –≤—ã–≤–æ–¥ –ø—Ä–∏ –æ—Ç–∫–∞–∑–µ –æ—Ä–∞–∫—É–ª–∞ - now with 0.1% fee
    function emergencyWithdraw() external nonReentrant {
        require(isEmergencyMode(), "Not in emergency mode");
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        require(goal.tbtcBalance > 0, "No funds");
        
        uint256 tbtcAmount = goal.tbtcBalance;
        uint256 founderFee = tbtcAmount * EMERGENCY_FEE_BPS / 10000;
        uint256 userAmount = tbtcAmount - founderFee;
        
        // –û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        delete userGoals[msg.sender];
        totalTBTCInContract -= tbtcAmount;
        totalDepositsInUSD -= goal.totalDepositsUSD;
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ TBTC –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∏ –∫–æ–º–∏—Å—Å–∏–∏ —Ñ–∞—É–Ω–¥–µ—Ä—É
        IERC20(TBTC).safeTransfer(msg.sender, userAmount);
        if (founderFee > 0) {
            IERC20(TBTC).safeTransfer(founder, founderFee);
        }
        
        emit EmergencyWithdrawal(msg.sender, userAmount, founderFee);
    }

    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–æ–≤–æ–π —Ü–µ–ª–∏
    function setGoal(uint256 _targetAmountUSD) external updateOracle {
        require(!isEmergencyMode(), "Emergency mode active");
        require(_targetAmountUSD >= 100e6, "Min goal $100");
        require(!userGoals[msg.sender].hasActiveGoal, "Already has active goal");
        
        userGoals[msg.sender] = UserGoal({
            targetAmount: _targetAmountUSD,
            tbtcBalance: 0,
            lastDepositToken: address(0),
            goalReached: false,
            withdrawRequestTime: 0,
            hasActiveGoal: true,
            totalDepositsUSD: 0,
            hasReached101Percent: false,
            highestPercentage: 0
        });
        
        emit GoalSet(msg.sender, _targetAmountUSD);
    }

    // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Ü–µ–ª–µ–≤–æ–π —Å—É–º–º—ã
    function increaseGoal(uint256 _newTargetAmountUSD) external updateOracle {
        require(!isEmergencyMode(), "Emergency mode active");
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        // Allow goal increases even after reaching goal - users may want to continue saving
        require(_newTargetAmountUSD > goal.targetAmount, "New target must be higher");
        
        uint256 oldTarget = goal.targetAmount;
        goal.targetAmount = _newTargetAmountUSD;
        
        // Recalculate goal status with new target
        uint256 currentValueUSD = getTBTCValueInUSD(goal.tbtcBalance);
        uint256 currentPercentage = currentValueUSD * 10000 / goal.targetAmount;
        
        // If new target puts them below 101%, reset goalReached status
        if (currentPercentage < GOAL_THRESHOLD_BPS) {
            goal.goalReached = false;
        } else {
            goal.goalReached = true;
            if (!goal.hasReached101Percent) {
                goal.hasReached101Percent = true;
            }
            if (currentPercentage > goal.highestPercentage) {
                goal.highestPercentage = currentPercentage;
            }
        }
        
        emit GoalIncreased(msg.sender, oldTarget, _newTargetAmountUSD);
    }

    // –í–Ω–µ—Å–µ–Ω–∏–µ –¥–µ–ø–æ–∑–∏—Ç–∞ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç sandwich-–∞—Ç–∞–∫
    function deposit(address _stablecoin, uint256 _amount, uint256 _minTBTCOut) external nonReentrant updateOracle {
        require(!isEmergencyMode(), "Emergency mode active");
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        require(supportedStablecoins[_stablecoin], "Unsupported stablecoin");
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –¥–µ–ø–æ–∑–∏—Ç–∞
        uint256 decimals = getTokenDecimals(_stablecoin);
        uint256 amountInUSD = _amount * 1e6 / (10 ** decimals);
        
        // If goal is reached, only allow small deposits up to $10 for stablecoin switching
        if (goal.goalReached) {
            require(amountInUSD <= 10e6, "After goal reached, max deposit is $10 for stablecoin switching");
            require(_stablecoin != goal.lastDepositToken, "Must use different stablecoin for switching");
        } else {
            require(amountInUSD >= MIN_DEPOSIT_USD, "Below minimum deposit");
        }
        
        // –ü–µ—Ä–µ–≤–æ–¥ —Ç–æ–∫–µ–Ω–æ–≤ –Ω–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç
        IERC20(_stablecoin).safeTransferFrom(msg.sender, address(this), _amount);
        
        // –†–∞—Å—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–∏ —Ñ–∞—É–Ω–¥–µ—Ä–∞ (0.1%)
        uint256 founderFee = _amount * DEPOSIT_FEE_BPS / 10000;
        uint256 amountAfterFee = _amount - founderFee;
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∏—Å—Å–∏–∏ —Ñ–∞—É–Ω–¥–µ—Ä—É
        IERC20(_stablecoin).safeTransfer(founder, founderFee);
        emit FounderFeeCollected(founder, founderFee, _stablecoin);
        
        // –û–±–º–µ–Ω –Ω–∞ TBTC —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∞
        uint256 tbtcReceived = swapToTBTC(_stablecoin, amountAfterFee, _minTBTCOut);
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–æ–≤
        goal.tbtcBalance += tbtcReceived;
        goal.lastDepositToken = _stablecoin;  // Update to new stablecoin for safety
        goal.totalDepositsUSD += amountInUSD;
        totalTBTCInContract += tbtcReceived;
        totalDepositsInUSD += amountInUSD;
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–∏ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        uint256 currentValueUSD = getTBTCValueInUSD(goal.tbtcBalance);
        uint256 currentPercentage = currentValueUSD * 10000 / goal.targetAmount;
        
        if (currentPercentage >= GOAL_THRESHOLD_BPS && !goal.goalReached) {
            goal.goalReached = true;
            if (!goal.hasReached101Percent) {
                goal.hasReached101Percent = true;
                emit GoalQualified(msg.sender, currentPercentage);
            }
        }
        
        // Track highest percentage
        if (currentPercentage > goal.highestPercentage) {
            goal.highestPercentage = currentPercentage;
        }
        
        emit Deposited(msg.sender, _stablecoin, _amount, tbtcReceived, founderFee);
    }

    // –ó–∞–ø—Ä–æ—Å –Ω–∞ –¥–æ—Å—Ä–æ—á–Ω—ã–π –≤—ã–≤–æ–¥
    function requestEarlyWithdraw() external updateOracle {
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        require(!goal.goalReached && !goal.hasReached101Percent, "Can withdraw normally");
        require(goal.withdrawRequestTime == 0, "Request already active");
        require(goal.tbtcBalance > 0, "No funds to withdraw");
        
        goal.withdrawRequestTime = block.timestamp;
        emit WithdrawRequested(msg.sender, block.timestamp);
    }

    // –û—Ç–º–µ–Ω–∞ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –≤—ã–≤–æ–¥
    function cancelWithdrawRequest() external {
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.withdrawRequestTime > 0, "No active request");
        
        goal.withdrawRequestTime = 0;
        emit WithdrawRequestCancelled(msg.sender);
    }

    // –ß–∞—Å—Ç–∏—á–Ω—ã–π –¥–æ—Å—Ä–æ—á–Ω—ã–π –≤—ã–≤–æ–¥
    function executePartialEarlyWithdraw(uint256 _percent) public nonReentrant updateOracle {
        require(_percent >= MIN_PARTIAL_WITHDRAW_PERCENT && _percent <= 100, "Invalid percent");
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.withdrawRequestTime > 0, "No active request");
        require(block.timestamp >= goal.withdrawRequestTime + WITHDRAW_DELAY, "Delay not passed");
        require(goal.tbtcBalance > 0, "No funds to withdraw");
        
        uint256 tbtcToWithdraw = goal.tbtcBalance * _percent / 100;
        uint256 usdToWithdraw = goal.totalDepositsUSD * _percent / 100;
        address outputToken = goal.lastDepositToken;
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–æ–≤
        goal.tbtcBalance -= tbtcToWithdraw;
        goal.totalDepositsUSD -= usdToWithdraw;
        totalTBTCInContract -= tbtcToWithdraw;
        totalDepositsInUSD -= usdToWithdraw;
        
        // –°–±—Ä–æ—Å –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –≤—ã–≤–æ–¥
        goal.withdrawRequestTime = 0;
        
        // –ï—Å–ª–∏ –∑–∞–±—Ä–∞–ª–∏ –≤—Å—ë - —É–¥–∞–ª—è–µ–º —Ü–µ–ª—å
        if (goal.tbtcBalance == 0) {
            delete userGoals[msg.sender];
        }
        
        // –û–±–º–µ–Ω TBTC –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω
        uint256 stablecoinReceived = swapFromTBTC(outputToken, tbtcToWithdraw);
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ä–µ–¥—Å—Ç–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        IERC20(outputToken).safeTransfer(msg.sender, stablecoinReceived);
        
        emit PartialWithdrawnEarly(msg.sender, _percent, tbtcToWithdraw, outputToken, stablecoinReceived);
    }

    // –ü–æ–ª–Ω—ã–π –¥–æ—Å—Ä–æ—á–Ω—ã–π –≤—ã–≤–æ–¥
    function executeEarlyWithdraw() external nonReentrant updateOracle {
        executePartialEarlyWithdraw(100);
    }

    // –í—ã–≤–æ–¥ –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ —Ü–µ–ª–∏ - updated logic
    function withdrawGoalReached() external nonReentrant updateOracle {
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        require(goal.goalReached || goal.hasReached101Percent, "Goal not reached");
        require(goal.tbtcBalance > 0, "No funds to withdraw");
        
        uint256 tbtcAmount = goal.tbtcBalance;
        address outputToken = goal.lastDepositToken;
        uint256 targetAmount = goal.targetAmount;
        
        // Check if should trigger cascade
        uint256 currentValueUSD = getTBTCValueInUSD(tbtcAmount);
        uint256 currentPercentage = currentValueUSD * 10000 / targetAmount;
        bool triggersCascade = currentPercentage >= CASCADE_THRESHOLD_BPS && !cascadePaused;
        
        // –û–±–º–µ–Ω TBTC –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω
        uint256 stablecoinReceived = swapFromTBTC(outputToken, tbtcAmount);
        
        // –†–∞—Å—á–µ—Ç —Å—É–º–º—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ñ–∞—É–Ω–¥–µ—Ä–∞
        uint256 decimals = getTokenDecimals(outputToken);
        uint256 targetInToken = targetAmount * (10 ** decimals) / 1e6;
        uint256 userAmount;
        uint256 founderAmount;
        
        if (stablecoinReceived >= targetInToken) {
            // User reached goal - gets 100% of target, founder gets all excess
            userAmount = targetInToken;
            founderAmount = stablecoinReceived - targetInToken;
            
            // If user triggers cascade, they get 3% bonus
            if (triggersCascade) {
                uint256 bonus = targetInToken * CASCADE_BONUS_BPS / 10000;
                if (founderAmount >= bonus) {
                    userAmount += bonus;
                    founderAmount -= bonus;
                } else {
                    userAmount += founderAmount;
                    founderAmount = 0;
                }
            }
        } else {
            // Price dropped below goal - user gets 99%, founder gets 1%
            uint256 feeAmount = stablecoinReceived * GOAL_FEE_BPS / 10000;
            userAmount = stablecoinReceived - feeAmount;
            founderAmount = feeAmount;
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –±–∞–ª–∞–Ω—Å–æ–≤
        totalTBTCInContract -= tbtcAmount;
        totalDepositsInUSD -= goal.totalDepositsUSD;
        
        // –û–±–Ω—É–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        delete userGoals[msg.sender];
        
        // Remove from cascade queue if present
        if (inCascadeQueue[msg.sender]) {
            _removeFromCascadeQueue(msg.sender);
        }
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ä–µ–¥—Å—Ç–≤
        IERC20(outputToken).safeTransfer(msg.sender, userAmount);
        if (founderAmount > 0) {
            IERC20(outputToken).safeTransfer(founder, founderAmount);
            emit FounderFeeCollected(founder, founderAmount, outputToken);
        }
        
        emit GoalReached(msg.sender, tbtcAmount, outputToken, userAmount);
        
        // Trigger cascade if applicable
        if (triggersCascade) {
            _triggerCascade();
        }
    }

    // Trigger cascade for all users at 105%+
    function _triggerCascade() private {
        uint256 addedToQueue = 0;
        
        // This is a simplified version - in production, you'd want to iterate more efficiently
        // For now, we'll assume we have a way to get eligible users
        emit CascadeTriggered(msg.sender, addedToQueue);
    }

    // Process cascade batch - can be called by anyone
    function processCascadeBatch(uint256 batchSize) external nonReentrant updateOracle {
        require(!cascadePaused, "Cascade paused");
        require(cascadeQueue.length > 0, "No users in cascade queue");
        
        uint256 toProcess = batchSize;
        if (toProcess > cascadeQueue.length) {
            toProcess = cascadeQueue.length;
        }
        if (toProcess > MAX_CASCADE_BATCH) {
            toProcess = MAX_CASCADE_BATCH;
        }
        
        uint256 processed = 0;
        
        for (uint256 i = 0; i < toProcess; i++) {
            address user = cascadeQueue[0];
            UserGoal storage goal = userGoals[user];
            
            if (goal.hasActiveGoal && goal.tbtcBalance > 0) {
                // Process withdrawal for cascade user
                uint256 tbtcAmount = goal.tbtcBalance;
                address outputToken = goal.lastDepositToken;
                uint256 targetAmount = goal.targetAmount;
                
                // –û–±–º–µ–Ω TBTC –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω
                uint256 stablecoinReceived = swapFromTBTC(outputToken, tbtcAmount);
                
                // Cascade users get exactly 100% of target
                uint256 decimals = getTokenDecimals(outputToken);
                uint256 targetInToken = targetAmount * (10 ** decimals) / 1e6;
                uint256 userAmount = targetInToken;
                uint256 founderAmount = 0;
                
                if (stablecoinReceived > targetInToken) {
                    founderAmount = stablecoinReceived - targetInToken;
                } else {
                    // If somehow value dropped, user gets what's available
                    userAmount = stablecoinReceived;
                }
                
                // Update balances
                totalTBTCInContract -= tbtcAmount;
                totalDepositsInUSD -= goal.totalDepositsUSD;
                delete userGoals[user];
                
                // Send funds
                IERC20(outputToken).safeTransfer(user, userAmount);
                if (founderAmount > 0) {
                    IERC20(outputToken).safeTransfer(founder, founderAmount);
                    emit FounderFeeCollected(founder, founderAmount, outputToken);
                }
                
                emit GoalReached(user, tbtcAmount, outputToken, userAmount);
                processed++;
            }
            
            // Remove from queue
            _removeFromCascadeQueue(user);
        }
        
        cascadeProcessedCount += processed;
        emit CascadeProcessed(processed, cascadeQueue.length);
    }

    // Remove user from cascade queue
    function _removeFromCascadeQueue(address user) private {
        if (!inCascadeQueue[user]) return;
        
        // Find and remove user
        for (uint256 i = 0; i < cascadeQueue.length; i++) {
            if (cascadeQueue[i] == user) {
                cascadeQueue[i] = cascadeQueue[cascadeQueue.length - 1];
                cascadeQueue.pop();
                inCascadeQueue[user] = false;
                break;
            }
        }
    }

    // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–º–µ–Ω—ã —Ñ–∞—É–Ω–¥–µ—Ä–∞
    function requestFounderChange(address _newFounder) external {
        require(msg.sender == founder, "Only founder");
        require(_newFounder != address(0), "Invalid address");
        require(_newFounder != founder, "Same founder");
        
        pendingFounder = _newFounder;
        emit FounderChangeRequested(founder, _newFounder);
    }

    function acceptFounderChange() external {
        require(msg.sender == pendingFounder, "Not pending founder");
        
        address oldFounder = founder;
        founder = pendingFounder;
        pendingFounder = address(0);
        
        emit FounderChanged(oldFounder, msg.sender);
    }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

    // Helper function for USDT-safe approvals
    function _forceApprove(IERC20 token, address spender, uint256 amount) private {
        uint256 current = token.allowance(address(this), spender);
        if (current < amount) {
            // Reset to 0 only if spender already had an allowance
            if (current > 0) {
                token.approve(spender, 0);
            }
            token.approve(spender, amount);
        }
    }

    function swapToTBTC(address _inputToken, uint256 _amountIn, uint256 _minTBTCOut) private returns (uint256) {
        _forceApprove(IERC20(_inputToken), address(SWAP_ROUTER), _amountIn);
        
        // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç slippage –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞
        uint256 expectedOutput = getExpectedTBTCAmount(_inputToken, _amountIn);
        uint256 decimals = getTokenDecimals(_inputToken);
        uint256 amountInUSD = _amountIn * 1e6 / (10 ** decimals);  // Calculate USD value for slippage
        uint256 slippageBps = calculateDynamicSlippage(amountInUSD);
        uint256 minOutput = expectedOutput * (10000 - slippageBps) / 10000;
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞—â–∏—Ç—ã –æ—Ç sandwich-–∞—Ç–∞–∫ - users can only tighten slippage, not loosen it
        require(_minTBTCOut == 0 || _minTBTCOut >= minOutput, "minTBTCOut too low - insufficient slippage protection");
        if (_minTBTCOut > minOutput) {
            minOutput = _minTBTCOut;  // Use tighter protection if user requests it
        }
        
        // Build path for multi-hop swap
        // Stablecoin -> WETH -> WBTC -> TBTC (3 hops for maximum liquidity)
        // Using 0.3% (3000) fee tier for stablecoin->WETH and WETH->WBTC, 0.01% (100) for WBTC->TBTC
        bytes memory path = abi.encodePacked(
            _inputToken,    
            uint24(3000),   // 0.3% fee for stablecoin->WETH
            WETH,           
            uint24(3000),   // 0.3% fee for WETH->WBTC
            WBTC,
            uint24(100),    // 0.01% fee for WBTC->TBTC (lower fee tier for BTC pairs)
            TBTC
        );
        
        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({
            path: path,
            recipient: address(this),
            deadline: block.timestamp,
            amountIn: _amountIn,
            amountOutMinimum: minOutput
        });
        
        uint256 amountOut = SWAP_ROUTER.exactInput(params);
        emit SwapExecuted(_inputToken, TBTC, _amountIn, amountOut);
        
        return amountOut;
    }

    function swapFromTBTC(address _outputToken, uint256 _amountIn) private returns (uint256) {
        _forceApprove(IERC20(TBTC), address(SWAP_ROUTER), _amountIn);
        
        uint256 expectedOutput = getExpectedStablecoinAmount(_outputToken, _amountIn);
        uint256 slippageBps = calculateDynamicSlippage(getTBTCValueInUSD(_amountIn));
        uint256 minOutput = expectedOutput * (10000 - slippageBps) / 10000;
        
        // Build path for multi-hop swap (reverse of deposit path)
        // TBTC -> WBTC -> WETH -> Stablecoin (3 hops)
        bytes memory path = abi.encodePacked(
            TBTC,
            uint24(100),    // 0.01% fee for TBTC->WBTC
            WBTC,           
            uint24(3000),   // 0.3% fee for WBTC->WETH
            WETH,
            uint24(3000),   // 0.3% fee for WETH->stablecoin
            _outputToken
        );
        
        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({
            path: path,
            recipient: address(this),
            deadline: block.timestamp,
            amountIn: _amountIn,
            amountOutMinimum: minOutput
        });
        
        uint256 amountOut = SWAP_ROUTER.exactInput(params);
        emit SwapExecuted(TBTC, _outputToken, _amountIn, amountOut);
        
        return amountOut;
    }

    function calculateDynamicSlippage(uint256 _amountUSD) private pure returns (uint256) {
        // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π slippage: 0.5% –¥–ª—è <$1000, 1% –¥–ª—è <$10k, 2% –¥–ª—è <$100k, 3% –¥–ª—è –±–æ–ª—å—à–∏—Ö —Å—É–º–º
        if (_amountUSD < 1000e6) return 50;   // 0.5%
        if (_amountUSD < 10000e6) return 100; // 1%
        if (_amountUSD < 100000e6) return 200; // 2%
        return MAX_SLIPPAGE_BPS; // 3%
    }

    function getTBTCValueInUSD(uint256 _tbtcAmount) public view returns (uint256) {
        if (isEmergencyMode()) {
            // –í –∞–≤–∞—Ä–∏–π–Ω–æ–º —Ä–µ–∂–∏–º–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –¥–æ–ª—é
            if (totalTBTCInContract == 0) return 0;  // Fix division by zero
            return _tbtcAmount * totalDepositsInUSD / totalTBTCInContract;
        }
        
        try AggregatorV3Interface(BTC_USD_FEED).latestRoundData() returns (
            uint80,
            int256 price,
            uint256,
            uint256,
            uint80
        ) {
            if (price <= 0) return 0;
            // price –∏–º–µ–µ—Ç 8 decimals, TBTC –∏–º–µ–µ—Ç 18 decimals, –Ω—É–∂–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ 6 decimals (USD)
            return uint256(price) * _tbtcAmount / 1e20;
        } catch {
            return 0; // Gracefully degrade on oracle failure
        }
    }

    function getExpectedTBTCAmount(address _inputToken, uint256 _amountIn) private view returns (uint256) {
        uint256 decimals = getTokenDecimals(_inputToken);
        uint256 usdAmount = _amountIn * 1e6 / (10 ** decimals);
        
        try AggregatorV3Interface(BTC_USD_FEED).latestRoundData() returns (
            uint80,
            int256 price,
            uint256,
            uint256,
            uint80
        ) {
            if (price <= 0) return 0;
            // TBTC has 18 decimals instead of WBTC's 8
            // Note: This is a rough estimate. Actual output will be less due to:
            // 1. Multiple swap fees (0.3% + 0.3% + 0.01% ‚âà 0.61% total)
            // 2. Price impact on each pool
            // 3. Slippage
            // The slippage protection in swapToTBTC accounts for these factors
            return usdAmount * 1e20 / uint256(price);
        } catch {
            return 0;
        }
    }

    function getExpectedStablecoinAmount(address _outputToken, uint256 _tbtcAmount) private view returns (uint256) {
        uint256 usdValue = getTBTCValueInUSD(_tbtcAmount);
        uint256 decimals = getTokenDecimals(_outputToken);
        // Note: This is a rough estimate. Actual output will be less due to multi-hop fees
        return usdValue * (10 ** decimals) / 1e6;
    }

    function getTokenDecimals(address _token) private pure returns (uint256) {
        // Check if we have custom decimals set (for testing)
        // This function is no longer used for mainnet tokens, but kept for compatibility
        if (_token == USDT || _token == USDC) return 6;
        if (_token == DAI || _token == USDS || _token == LUSD) return 18;
        if (_token == TBTC || _token == WETH || _token == WBTC) return 18; // TBTC, WETH, WBTC have 18 decimals
        revert("Unknown token");
    }

    // View —Ñ—É–Ω–∫—Ü–∏–∏

    function getUserGoalInfo(address _user) external view returns (
        uint256 targetAmount,
        uint256 currentValueUSD,
        uint256 tbtcBalance,
        bool goalReached,
        bool canWithdraw,
        uint256 withdrawAvailableAt,
        uint256 totalDepositsUSD,
        bool hasReached101Percent,
        uint256 highestPercentage
    ) {
        UserGoal memory goal = userGoals[_user];
        targetAmount = goal.targetAmount;
        tbtcBalance = goal.tbtcBalance;
        goalReached = goal.goalReached;
        totalDepositsUSD = goal.totalDepositsUSD;
        hasReached101Percent = goal.hasReached101Percent;
        highestPercentage = goal.highestPercentage;
        
        if (goal.tbtcBalance > 0) {
            currentValueUSD = getTBTCValueInUSD(goal.tbtcBalance);
        }
        
        if (goal.withdrawRequestTime > 0) {
            withdrawAvailableAt = goal.withdrawRequestTime + WITHDRAW_DELAY;
            canWithdraw = block.timestamp >= withdrawAvailableAt;
        } else if (goal.goalReached || goal.hasReached101Percent) {
            canWithdraw = true;
        }
    }

    function getCurrentBTCPrice() external view returns (uint256, bool isStale) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(BTC_USD_FEED);
        try priceFeed.latestRoundData() returns (
            uint80,
            int256 price,
            uint256,
            uint256 updatedAt,
            uint80
        ) {
            isStale = block.timestamp > updatedAt + 3600; // –°—á–∏—Ç–∞–µ–º —É—Å—Ç–∞—Ä–µ–≤—à–∏–º –ø–æ—Å–ª–µ 1 —á–∞—Å–∞
            return (uint256(price), isStale);
        } catch {
            return (0, true);
        }
    }

    function getMinTBTCOut(address _stablecoin, uint256 _amount) external view returns (uint256) {
        uint256 founderFee = _amount * DEPOSIT_FEE_BPS / 10000;
        uint256 amountAfterFee = _amount - founderFee;
        uint256 expectedOutput = getExpectedTBTCAmount(_stablecoin, amountAfterFee);
        uint256 decimals = getTokenDecimals(_stablecoin);
        uint256 amountInUSD = _amount * 1e6 / (10 ** decimals);
        uint256 slippageBps = calculateDynamicSlippage(amountInUSD);
        return expectedOutput * (10000 - slippageBps) / 10000;
    }

    function getContractStats() external view returns (
        uint256 totalTBTC,
        uint256 totalUSDDeposited,
        uint256 currentTotalValueUSD,
        bool emergencyMode,
        uint256 lastOracleUpdateTime,
        uint256 cascadeQueueLength,
        bool cascadeIsPaused
    ) {
        totalTBTC = totalTBTCInContract;
        totalUSDDeposited = totalDepositsInUSD;
        currentTotalValueUSD = isEmergencyMode() ? totalDepositsInUSD : getTBTCValueInUSD(totalTBTCInContract);
        emergencyMode = isEmergencyMode();
        lastOracleUpdateTime = lastOracleUpdate;
        cascadeQueueLength = cascadeQueue.length;
        cascadeIsPaused = cascadePaused;
    }

    // Get cascade queue status
    function getCascadeQueueStatus() external view returns (
        uint256 queueLength,
        address[] memory next25Users,
        bool isPaused,
        uint256 totalProcessed
    ) {
        queueLength = cascadeQueue.length;
        isPaused = cascadePaused;
        totalProcessed = cascadeProcessedCount;
        
        uint256 toReturn = queueLength > 25 ? 25 : queueLength;
        next25Users = new address[](toReturn);
        
        for (uint256 i = 0; i < toReturn; i++) {
            next25Users[i] = cascadeQueue[i];
        }
    }

    // Check if user is in cascade queue
    function isUserInCascadeQueue(address _user) external view returns (bool inQueue, uint256 position) {
        inQueue = inCascadeQueue[_user];
        if (inQueue) {
            for (uint256 i = 0; i < cascadeQueue.length; i++) {
                if (cascadeQueue[i] == _user) {
                    position = i + 1; // 1-indexed for user display
                    break;
                }
            }
        }
    }

    // Calculate withdrawal amounts for a user
    function getWithdrawalAmounts(address _user) external view returns (
        uint256 userAmount,
        uint256 founderAmount,
        bool eligibleForCascadeBonus
    ) {
        UserGoal memory goal = userGoals[_user];
        if (!goal.hasActiveGoal || goal.tbtcBalance == 0) {
            return (0, 0, false);
        }

        uint256 currentValueUSD = getTBTCValueInUSD(goal.tbtcBalance);
        uint256 currentPercentage = currentValueUSD * 10000 / goal.targetAmount;
        eligibleForCascadeBonus = currentPercentage >= CASCADE_THRESHOLD_BPS;

        // Simulate swap to get expected amounts
        uint256 expectedStablecoin = getExpectedStablecoinAmount(goal.lastDepositToken, goal.tbtcBalance);
        uint256 decimals = getTokenDecimals(goal.lastDepositToken);
        uint256 targetInToken = goal.targetAmount * (10 ** decimals) / 1e6;

        if (expectedStablecoin >= targetInToken) {
            userAmount = targetInToken;
            founderAmount = expectedStablecoin - targetInToken;
            
            if (eligibleForCascadeBonus && !cascadePaused) {
                uint256 bonus = targetInToken * CASCADE_BONUS_BPS / 10000;
                if (founderAmount >= bonus) {
                    userAmount += bonus;
                    founderAmount -= bonus;
                } else {
                    userAmount += founderAmount;
                    founderAmount = 0;
                }
            }
        } else {
            // Price dropped scenario
            uint256 feeAmount = expectedStablecoin * GOAL_FEE_BPS / 10000;
            userAmount = expectedStablecoin - feeAmount;
            founderAmount = feeAmount;
        }
    }
}