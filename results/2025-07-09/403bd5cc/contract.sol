/*
 * Solidity Contract
 * Generated by Simple Test - AI-Powered Solidity Testing
 * 
 * Contract Hash: unknown
 * Generated At: 2025-07-09T20:09:16.130Z
 * AI Model: gemini-1.5-flash
 * Execution Time: 23.01s
 * 
 * 🤖 This file was automatically generated
 * 🔗 Visit https://test.smplai.io to generate your own tests
 */

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";

contract DePiggyBank is ReentrancyGuard {
    using SafeERC20 for IERC20;

    // Структура для хранения данных о цели пользователя
    struct UserGoal {
        uint256 targetAmount;        // Целевая сумма в USD (6 decimals)
        uint256 tbtcBalance;         // Накопленный TBTC (18 decimals)
        address lastDepositToken;    // Последний использованный стейблкоин
        bool goalReached;            // Достигнута ли цель (101%)
        uint256 withdrawRequestTime; // Время заявки на досрочный вывод
        bool hasActiveGoal;          // Есть ли активная цель
        uint256 totalDepositsUSD;    // Общая сумма депозитов в USD для расчета долей
        bool hasReached101Percent;   // Historical tracking of 101% achievement
        uint256 highestPercentage;   // Track highest percentage reached
    }

    // Структура для каскадной системы
    struct CascadeUser {
        address user;
        uint256 goalId;
        uint256 percentage;
    }

    // Константы
    uint256 public constant DEPOSIT_FEE_BPS = 10;        // 0.1% = 10 базисных пунктов
    uint256 public constant GOAL_FEE_BPS = 100;          // 1% = 100 базисных пунктов
    uint256 public constant GOAL_THRESHOLD_BPS = 10100;  // 101% = 10100 базисных пунктов
    uint256 public constant CASCADE_THRESHOLD_BPS = 10500; // 105% = 10500 базисных пунктов
    uint256 public constant CASCADE_BONUS_BPS = 300;     // 3% = 300 базисных пунктов
    uint256 public constant EMERGENCY_FEE_BPS = 10;      // 0.1% = 10 базисных пунктов
    uint256 public constant MIN_DEPOSIT_USD = 10e6;      // $10 с 6 decimals
    uint256 public constant WITHDRAW_DELAY = 30 days;    // 30 дней задержка
    uint256 public constant ORACLE_TIMEOUT = 30 days;    // 30 дней таймаут оракула
    uint24 public constant POOL_FEE = 3000;              // 0.3% комиссия пула Uniswap
    uint256 public constant MAX_SLIPPAGE_BPS = 300;      // 3% максимальный slippage
    uint256 public constant MIN_PARTIAL_WITHDRAW_PERCENT = 10; // Минимум 10% для частичного вывода
    uint256 public constant MAX_CASCADE_BATCH = 25;      // Maximum users to process in one cascade batch

    // Адреса токенов на Ethereum mainnet
    address public constant TBTC = 0x18084fbA666a33d37592fA2633fD49a74DD93a88; // TBTC mainnet address
    address public constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant USDS = 0xdC035D45d973E3EC169d2276DDab16f1e407384F;
    address public constant LUSD = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH for routing
    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC for routing
    
    // Адреса Chainlink price feeds
    address public constant BTC_USD_FEED = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c; // BTC/USD mainnet feed
    
    // Uniswap V3 Router
    ISwapRouter public constant SWAP_ROUTER = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564); // Mainnet router

    // Состояние контракта
    address public founder;  // Changed from immutable to allow founder changes
    address public pendingFounder;
    uint256 public lastOracleUpdate;
    uint256 public totalTBTCInContract;
    uint256 public totalDepositsInUSD;
    mapping(address => UserGoal) public userGoals;
    mapping(address => bool) public supportedStablecoins;
    
    // Cascade system state
    address[] public cascadeQueue;
    mapping(address => bool) public inCascadeQueue;
    bool public cascadePaused;
    uint256 public cascadeProcessedCount;

    // События
    event GoalSet(address indexed user, uint256 targetAmount);
    event GoalIncreased(address indexed user, uint256 oldTarget, uint256 newTarget);
    event Deposited(address indexed user, address token, uint256 amount, uint256 tbtcReceived, uint256 founderFee);
    event WithdrawRequested(address indexed user, uint256 timestamp);
    event WithdrawRequestCancelled(address indexed user);
    event PartialWithdrawnEarly(address indexed user, uint256 percent, uint256 tbtcAmount, address token, uint256 usdAmount);
    event WithdrawnEarly(address indexed user, uint256 tbtcAmount, address token, uint256 usdAmount);
    event GoalReached(address indexed user, uint256 tbtcAmount, address token, uint256 usdAmount);
    event FounderFeeCollected(address indexed founder, uint256 amount, address token);
    event FounderChanged(address indexed oldFounder, address indexed newFounder);
    event FounderChangeRequested(address indexed currentFounder, address indexed pendingFounder);
    event OracleUpdated(uint256 timestamp, int256 price);
    event EmergencyModeActivated(uint256 timestamp);
    event EmergencyWithdrawal(address indexed user, uint256 tbtcAmount, uint256 founderFee);
    event SwapExecuted(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);
    event GoalQualified(address indexed user, uint256 percentage);
    event CascadeTriggered(address indexed trigger, uint256 totalUsers);
    event CascadeProcessed(uint256 usersProcessed, uint256 remaining);
    event CascadePausedToggled(bool paused);

    modifier updateOracle() {
        _updateOraclePrice();
        _;
    }

    constructor(address _founder) {
        require(_founder != address(0), "Invalid founder");
        founder = _founder;
        
        // Инициализация поддерживаемых стейблкоинов
        supportedStablecoins[USDT] = true;
        supportedStablecoins[USDC] = true;
        supportedStablecoins[DAI] = true;
        supportedStablecoins[USDS] = true;
        supportedStablecoins[LUSD] = true;
        
        // Set initial timestamp to prevent immediate emergency mode
        lastOracleUpdate = block.timestamp;
    }

    // Initialize oracle after deployment (for production)
    function initializeOracle() external {
        require(msg.sender == founder, "Only founder");
        _updateOraclePrice();
    }

    // Обновление цены оракула
    function _updateOraclePrice() private {
        try AggregatorV3Interface(BTC_USD_FEED).latestRoundData() returns (
            uint80,
            int256 price,
            uint256,
            uint256 updatedAt,
            uint80
        ) {
            if (price > 0 && updatedAt > 0) {
                lastOracleUpdate = block.timestamp;
                emit OracleUpdated(block.timestamp, price);
            }
        } catch {
            // Оракул не отвечает, проверяем таймаут
            if (block.timestamp > lastOracleUpdate + ORACLE_TIMEOUT) {
                emit EmergencyModeActivated(block.timestamp);
            }
        }
    }

    // Проверка аварийного режима
    function isEmergencyMode() public view returns (bool) {
        return block.timestamp > lastOracleUpdate + ORACLE_TIMEOUT;
    }

    // Аварийный вывод при отказе оракула - now with 0.1% fee
    function emergencyWithdraw() external nonReentrant {
        require(isEmergencyMode(), "Not in emergency mode");
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        require(goal.tbtcBalance > 0, "No funds");
        
        uint256 tbtcAmount = goal.tbtcBalance;
        uint256 founderFee = tbtcAmount * EMERGENCY_FEE_BPS / 10000;
        uint256 userAmount = tbtcAmount - founderFee;
        
        // Очистка данных пользователя
        delete userGoals[msg.sender];
        totalTBTCInContract -= tbtcAmount;
        totalDepositsInUSD -= goal.totalDepositsUSD;
        
        // Отправка TBTC пользователю и комиссии фаундеру
        IERC20(TBTC).safeTransfer(msg.sender, userAmount);
        if (founderFee > 0) {
            IERC20(TBTC).safeTransfer(founder, founderFee);
        }
        
        emit EmergencyWithdrawal(msg.sender, userAmount, founderFee);
    }

    // Установка новой цели
    function setGoal(uint256 _targetAmountUSD) external updateOracle {
        require(!isEmergencyMode(), "Emergency mode active");
        require(_targetAmountUSD >= 100e6, "Min goal $100");
        require(!userGoals[msg.sender].hasActiveGoal, "Already has active goal");
        
        userGoals[msg.sender] = UserGoal({
            targetAmount: _targetAmountUSD,
            tbtcBalance: 0,
            lastDepositToken: address(0),
            goalReached: false,
            withdrawRequestTime: 0,
            hasActiveGoal: true,
            totalDepositsUSD: 0,
            hasReached101Percent: false,
            highestPercentage: 0
        });
        
        emit GoalSet(msg.sender, _targetAmountUSD);
    }

    // Увеличение целевой суммы
    function increaseGoal(uint256 _newTargetAmountUSD) external updateOracle {
        require(!isEmergencyMode(), "Emergency mode active");
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        // Allow goal increases even after reaching goal - users may want to continue saving
        require(_newTargetAmountUSD > goal.targetAmount, "New target must be higher");
        
        uint256 oldTarget = goal.targetAmount;
        goal.targetAmount = _newTargetAmountUSD;
        
        // Recalculate goal status with new target
        uint256 currentValueUSD = getTBTCValueInUSD(goal.tbtcBalance);
        uint256 currentPercentage = currentValueUSD * 10000 / goal.targetAmount;
        
        // If new target puts them below 101%, reset goalReached status
        if (currentPercentage < GOAL_THRESHOLD_BPS) {
            goal.goalReached = false;
        } else {
            goal.goalReached = true;
            if (!goal.hasReached101Percent) {
                goal.hasReached101Percent = true;
            }
            if (currentPercentage > goal.highestPercentage) {
                goal.highestPercentage = currentPercentage;
            }
        }
        
        emit GoalIncreased(msg.sender, oldTarget, _newTargetAmountUSD);
    }

    // Внесение депозита с защитой от sandwich-атак
    function deposit(address _stablecoin, uint256 _amount, uint256 _minTBTCOut) external nonReentrant updateOracle {
        require(!isEmergencyMode(), "Emergency mode active");
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        require(supportedStablecoins[_stablecoin], "Unsupported stablecoin");
        
        // Проверка минимального депозита
        uint256 decimals = getTokenDecimals(_stablecoin);
        uint256 amountInUSD = _amount * 1e6 / (10 ** decimals);
        
        // If goal is reached, only allow small deposits up to $10 for stablecoin switching
        if (goal.goalReached) {
            require(amountInUSD <= 10e6, "After goal reached, max deposit is $10 for stablecoin switching");
            require(_stablecoin != goal.lastDepositToken, "Must use different stablecoin for switching");
        } else {
            require(amountInUSD >= MIN_DEPOSIT_USD, "Below minimum deposit");
        }
        
        // Перевод токенов на контракт
        IERC20(_stablecoin).safeTransferFrom(msg.sender, address(this), _amount);
        
        // Расчет комиссии фаундера (0.1%)
        uint256 founderFee = _amount * DEPOSIT_FEE_BPS / 10000;
        uint256 amountAfterFee = _amount - founderFee;
        
        // Отправка комиссии фаундеру
        IERC20(_stablecoin).safeTransfer(founder, founderFee);
        emit FounderFeeCollected(founder, founderFee, _stablecoin);
        
        // Обмен на TBTC с проверкой минимального выхода
        uint256 tbtcReceived = swapToTBTC(_stablecoin, amountAfterFee, _minTBTCOut);
        
        // Обновление балансов
        goal.tbtcBalance += tbtcReceived;
        goal.lastDepositToken = _stablecoin;  // Update to new stablecoin for safety
        goal.totalDepositsUSD += amountInUSD;
        totalTBTCInContract += tbtcReceived;
        totalDepositsInUSD += amountInUSD;
        
        // Проверка достижения цели и обновление статуса
        uint256 currentValueUSD = getTBTCValueInUSD(goal.tbtcBalance);
        uint256 currentPercentage = currentValueUSD * 10000 / goal.targetAmount;
        
        if (currentPercentage >= GOAL_THRESHOLD_BPS && !goal.goalReached) {
            goal.goalReached = true;
            if (!goal.hasReached101Percent) {
                goal.hasReached101Percent = true;
                emit GoalQualified(msg.sender, currentPercentage);
            }
        }
        
        // Track highest percentage
        if (currentPercentage > goal.highestPercentage) {
            goal.highestPercentage = currentPercentage;
        }
        
        emit Deposited(msg.sender, _stablecoin, _amount, tbtcReceived, founderFee);
    }

    // Запрос на досрочный вывод
    function requestEarlyWithdraw() external updateOracle {
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        require(!goal.goalReached && !goal.hasReached101Percent, "Can withdraw normally");
        require(goal.withdrawRequestTime == 0, "Request already active");
        require(goal.tbtcBalance > 0, "No funds to withdraw");
        
        goal.withdrawRequestTime = block.timestamp;
        emit WithdrawRequested(msg.sender, block.timestamp);
    }

    // Отмена запроса на вывод
    function cancelWithdrawRequest() external {
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.withdrawRequestTime > 0, "No active request");
        
        goal.withdrawRequestTime = 0;
        emit WithdrawRequestCancelled(msg.sender);
    }

    // Частичный досрочный вывод
    function executePartialEarlyWithdraw(uint256 _percent) public nonReentrant updateOracle {
        require(_percent >= MIN_PARTIAL_WITHDRAW_PERCENT && _percent <= 100, "Invalid percent");
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.withdrawRequestTime > 0, "No active request");
        require(block.timestamp >= goal.withdrawRequestTime + WITHDRAW_DELAY, "Delay not passed");
        require(goal.tbtcBalance > 0, "No funds to withdraw");
        
        uint256 tbtcToWithdraw = goal.tbtcBalance * _percent / 100;
        uint256 usdToWithdraw = goal.totalDepositsUSD * _percent / 100;
        address outputToken = goal.lastDepositToken;
        
        // Обновление балансов
        goal.tbtcBalance -= tbtcToWithdraw;
        goal.totalDepositsUSD -= usdToWithdraw;
        totalTBTCInContract -= tbtcToWithdraw;
        totalDepositsInUSD -= usdToWithdraw;
        
        // Сброс запроса на вывод
        goal.withdrawRequestTime = 0;
        
        // Если забрали всё - удаляем цель
        if (goal.tbtcBalance == 0) {
            delete userGoals[msg.sender];
        }
        
        // Обмен TBTC обратно на стейблкоин
        uint256 stablecoinReceived = swapFromTBTC(outputToken, tbtcToWithdraw);
        
        // Отправка средств пользователю
        IERC20(outputToken).safeTransfer(msg.sender, stablecoinReceived);
        
        emit PartialWithdrawnEarly(msg.sender, _percent, tbtcToWithdraw, outputToken, stablecoinReceived);
    }

    // Полный досрочный вывод
    function executeEarlyWithdraw() external nonReentrant updateOracle {
        executePartialEarlyWithdraw(100);
    }

    // Вывод при достижении цели - updated logic
    function withdrawGoalReached() external nonReentrant updateOracle {
        UserGoal storage goal = userGoals[msg.sender];
        require(goal.hasActiveGoal, "No active goal");
        require(goal.goalReached || goal.hasReached101Percent, "Goal not reached");
        require(goal.tbtcBalance > 0, "No funds to withdraw");
        
        uint256 tbtcAmount = goal.tbtcBalance;
        address outputToken = goal.lastDepositToken;
        uint256 targetAmount = goal.targetAmount;
        
        // Check if should trigger cascade
        uint256 currentValueUSD = getTBTCValueInUSD(tbtcAmount);
        uint256 currentPercentage = currentValueUSD * 10000 / targetAmount;
        bool triggersCascade = currentPercentage >= CASCADE_THRESHOLD_BPS && !cascadePaused;
        
        // Обмен TBTC обратно на стейблкоин
        uint256 stablecoinReceived = swapFromTBTC(outputToken, tbtcAmount);
        
        // Расчет суммы для пользователя и фаундера
        uint256 decimals = getTokenDecimals(outputToken);
        uint256 targetInToken = targetAmount * (10 ** decimals) / 1e6;
        uint256 userAmount;
        uint256 founderAmount;
        
        if (stablecoinReceived >= targetInToken) {
            // User reached goal - gets 100% of target, founder gets all excess
            userAmount = targetInToken;
            founderAmount = stablecoinReceived - targetInToken;
            
            // If user triggers cascade, they get 3% bonus
            if (triggersCascade) {
                uint256 bonus = targetInToken * CASCADE_BONUS_BPS / 10000;
                if (founderAmount >= bonus) {
                    userAmount += bonus;
                    founderAmount -= bonus;
                } else {
                    userAmount += founderAmount;
                    founderAmount = 0;
                }
            }
        } else {
            // Price dropped below goal - user gets 99%, founder gets 1%
            uint256 feeAmount = stablecoinReceived * GOAL_FEE_BPS / 10000;
            userAmount = stablecoinReceived - feeAmount;
            founderAmount = feeAmount;
        }
        
        // Обновление глобальных балансов
        totalTBTCInContract -= tbtcAmount;
        totalDepositsInUSD -= goal.totalDepositsUSD;
        
        // Обнуление данных пользователя
        delete userGoals[msg.sender];
        
        // Remove from cascade queue if present
        if (inCascadeQueue[msg.sender]) {
            _removeFromCascadeQueue(msg.sender);
        }
        
        // Отправка средств
        IERC20(outputToken).safeTransfer(msg.sender, userAmount);
        if (founderAmount > 0) {
            IERC20(outputToken).safeTransfer(founder, founderAmount);
            emit FounderFeeCollected(founder, founderAmount, outputToken);
        }
        
        emit GoalReached(msg.sender, tbtcAmount, outputToken, userAmount);
        
        // Trigger cascade if applicable
        if (triggersCascade) {
            _triggerCascade();
        }
    }

    // Trigger cascade for all users at 105%+
    function _triggerCascade() private {
        uint256 addedToQueue = 0;
        
        // This is a simplified version - in production, you'd want to iterate more efficiently
        // For now, we'll assume we have a way to get eligible users
        emit CascadeTriggered(msg.sender, addedToQueue);
    }

    // Process cascade batch - can be called by anyone
    function processCascadeBatch(uint256 batchSize) external nonReentrant updateOracle {
        require(!cascadePaused, "Cascade paused");
        require(cascadeQueue.length > 0, "No users in cascade queue");
        
        uint256 toProcess = batchSize;
        if (toProcess > cascadeQueue.length) {
            toProcess = cascadeQueue.length;
        }
        if (toProcess > MAX_CASCADE_BATCH) {
            toProcess = MAX_CASCADE_BATCH;
        }
        
        uint256 processed = 0;
        
        for (uint256 i = 0; i < toProcess; i++) {
            address user = cascadeQueue[0];
            UserGoal storage goal = userGoals[user];
            
            if (goal.hasActiveGoal && goal.tbtcBalance > 0) {
                // Process withdrawal for cascade user
                uint256 tbtcAmount = goal.tbtcBalance;
                address outputToken = goal.lastDepositToken;
                uint256 targetAmount = goal.targetAmount;
                
                // Обмен TBTC обратно на стейблкоин
                uint256 stablecoinReceived = swapFromTBTC(outputToken, tbtcAmount);
                
                // Cascade users get exactly 100% of target
                uint256 decimals = getTokenDecimals(outputToken);
                uint256 targetInToken = targetAmount * (10 ** decimals) / 1e6;
                uint256 userAmount = targetInToken;
                uint256 founderAmount = 0;
                
                if (stablecoinReceived > targetInToken) {
                    founderAmount = stablecoinReceived - targetInToken;
                } else {
                    // If somehow value dropped, user gets what's available
                    userAmount = stablecoinReceived;
                }
                
                // Update balances
                totalTBTCInContract -= tbtcAmount;
                totalDepositsInUSD -= goal.totalDepositsUSD;
                delete userGoals[user];
                
                // Send funds
                IERC20(outputToken).safeTransfer(user, userAmount);
                if (founderAmount > 0) {
                    IERC20(outputToken).safeTransfer(founder, founderAmount);
                    emit FounderFeeCollected(founder, founderAmount, outputToken);
                }
                
                emit GoalReached(user, tbtcAmount, outputToken, userAmount);
                processed++;
            }
            
            // Remove from queue
            _removeFromCascadeQueue(user);
        }
        
        cascadeProcessedCount += processed;
        emit CascadeProcessed(processed, cascadeQueue.length);
    }

    // Remove user from cascade queue
    function _removeFromCascadeQueue(address user) private {
        if (!inCascadeQueue[user]) return;
        
        // Find and remove user
        for (uint256 i = 0; i < cascadeQueue.length; i++) {
            if (cascadeQueue[i] == user) {
                cascadeQueue[i] = cascadeQueue[cascadeQueue.length - 1];
                cascadeQueue.pop();
                inCascadeQueue[user] = false;
                break;
            }
        }
    }

    // Функции для смены фаундера
    function requestFounderChange(address _newFounder) external {
        require(msg.sender == founder, "Only founder");
        require(_newFounder != address(0), "Invalid address");
        require(_newFounder != founder, "Same founder");
        
        pendingFounder = _newFounder;
        emit FounderChangeRequested(founder, _newFounder);
    }

    function acceptFounderChange() external {
        require(msg.sender == pendingFounder, "Not pending founder");
        
        address oldFounder = founder;
        founder = pendingFounder;
        pendingFounder = address(0);
        
        emit FounderChanged(oldFounder, msg.sender);
    }

    // Вспомогательные функции

    // Helper function for USDT-safe approvals
    function _forceApprove(IERC20 token, address spender, uint256 amount) private {
        uint256 current = token.allowance(address(this), spender);
        if (current < amount) {
            // Reset to 0 only if spender already had an allowance
            if (current > 0) {
                token.approve(spender, 0);
            }
            token.approve(spender, amount);
        }
    }

    function swapToTBTC(address _inputToken, uint256 _amountIn, uint256 _minTBTCOut) private returns (uint256) {
        _forceApprove(IERC20(_inputToken), address(SWAP_ROUTER), _amountIn);
        
        // Динамический расчет slippage в зависимости от размера
        uint256 expectedOutput = getExpectedTBTCAmount(_inputToken, _amountIn);
        uint256 decimals = getTokenDecimals(_inputToken);
        uint256 amountInUSD = _amountIn * 1e6 / (10 ** decimals);  // Calculate USD value for slippage
        uint256 slippageBps = calculateDynamicSlippage(amountInUSD);
        uint256 minOutput = expectedOutput * (10000 - slippageBps) / 10000;
        
        // Проверка защиты от sandwich-атак - users can only tighten slippage, not loosen it
        require(_minTBTCOut == 0 || _minTBTCOut >= minOutput, "minTBTCOut too low - insufficient slippage protection");
        if (_minTBTCOut > minOutput) {
            minOutput = _minTBTCOut;  // Use tighter protection if user requests it
        }
        
        // Build path for multi-hop swap
        // Stablecoin -> WETH -> WBTC -> TBTC (3 hops for maximum liquidity)
        // Using 0.3% (3000) fee tier for stablecoin->WETH and WETH->WBTC, 0.01% (100) for WBTC->TBTC
        bytes memory path = abi.encodePacked(
            _inputToken,    
            uint24(3000),   // 0.3% fee for stablecoin->WETH
            WETH,           
            uint24(3000),   // 0.3% fee for WETH->WBTC
            WBTC,
            uint24(100),    // 0.01% fee for WBTC->TBTC (lower fee tier for BTC pairs)
            TBTC
        );
        
        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({
            path: path,
            recipient: address(this),
            deadline: block.timestamp,
            amountIn: _amountIn,
            amountOutMinimum: minOutput
        });
        
        uint256 amountOut = SWAP_ROUTER.exactInput(params);
        emit SwapExecuted(_inputToken, TBTC, _amountIn, amountOut);
        
        return amountOut;
    }

    function swapFromTBTC(address _outputToken, uint256 _amountIn) private returns (uint256) {
        _forceApprove(IERC20(TBTC), address(SWAP_ROUTER), _amountIn);
        
        uint256 expectedOutput = getExpectedStablecoinAmount(_outputToken, _amountIn);
        uint256 slippageBps = calculateDynamicSlippage(getTBTCValueInUSD(_amountIn));
        uint256 minOutput = expectedOutput * (10000 - slippageBps) / 10000;
        
        // Build path for multi-hop swap (reverse of deposit path)
        // TBTC -> WBTC -> WETH -> Stablecoin (3 hops)
        bytes memory path = abi.encodePacked(
            TBTC,
            uint24(100),    // 0.01% fee for TBTC->WBTC
            WBTC,           
            uint24(3000),   // 0.3% fee for WBTC->WETH
            WETH,
            uint24(3000),   // 0.3% fee for WETH->stablecoin
            _outputToken
        );
        
        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({
            path: path,
            recipient: address(this),
            deadline: block.timestamp,
            amountIn: _amountIn,
            amountOutMinimum: minOutput
        });
        
        uint256 amountOut = SWAP_ROUTER.exactInput(params);
        emit SwapExecuted(TBTC, _outputToken, _amountIn, amountOut);
        
        return amountOut;
    }

    function calculateDynamicSlippage(uint256 _amountUSD) private pure returns (uint256) {
        // Динамический slippage: 0.5% для <$1000, 1% для <$10k, 2% для <$100k, 3% для больших сумм
        if (_amountUSD < 1000e6) return 50;   // 0.5%
        if (_amountUSD < 10000e6) return 100; // 1%
        if (_amountUSD < 100000e6) return 200; // 2%
        return MAX_SLIPPAGE_BPS; // 3%
    }

    function getTBTCValueInUSD(uint256 _tbtcAmount) public view returns (uint256) {
        if (isEmergencyMode()) {
            // В аварийном режиме возвращаем пропорциональную долю
            if (totalTBTCInContract == 0) return 0;  // Fix division by zero
            return _tbtcAmount * totalDepositsInUSD / totalTBTCInContract;
        }
        
        try AggregatorV3Interface(BTC_USD_FEED).latestRoundData() returns (
            uint80,
            int256 price,
            uint256,
            uint256,
            uint80
        ) {
            if (price <= 0) return 0;
            // price имеет 8 decimals, TBTC имеет 18 decimals, нужен результат в 6 decimals (USD)
            return uint256(price) * _tbtcAmount / 1e20;
        } catch {
            return 0; // Gracefully degrade on oracle failure
        }
    }

    function getExpectedTBTCAmount(address _inputToken, uint256 _amountIn) private view returns (uint256) {
        uint256 decimals = getTokenDecimals(_inputToken);
        uint256 usdAmount = _amountIn * 1e6 / (10 ** decimals);
        
        try AggregatorV3Interface(BTC_USD_FEED).latestRoundData() returns (
            uint80,
            int256 price,
            uint256,
            uint256,
            uint80
        ) {
            if (price <= 0) return 0;
            // TBTC has 18 decimals instead of WBTC's 8
            // Note: This is a rough estimate. Actual output will be less due to:
            // 1. Multiple swap fees (0.3% + 0.3% + 0.01% ≈ 0.61% total)
            // 2. Price impact on each pool
            // 3. Slippage
            // The slippage protection in swapToTBTC accounts for these factors
            return usdAmount * 1e20 / uint256(price);
        } catch {
            return 0;
        }
    }

    function getExpectedStablecoinAmount(address _outputToken, uint256 _tbtcAmount) private view returns (uint256) {
        uint256 usdValue = getTBTCValueInUSD(_tbtcAmount);
        uint256 decimals = getTokenDecimals(_outputToken);
        // Note: This is a rough estimate. Actual output will be less due to multi-hop fees
        return usdValue * (10 ** decimals) / 1e6;
    }

    function getTokenDecimals(address _token) private pure returns (uint256) {
        // Check if we have custom decimals set (for testing)
        // This function is no longer used for mainnet tokens, but kept for compatibility
        if (_token == USDT || _token == USDC) return 6;
        if (_token == DAI || _token == USDS || _token == LUSD) return 18;
        if (_token == TBTC || _token == WETH || _token == WBTC) return 18; // TBTC, WETH, WBTC have 18 decimals
        revert("Unknown token");
    }

    // View функции

    function getUserGoalInfo(address _user) external view returns (
        uint256 targetAmount,
        uint256 currentValueUSD,
        uint256 tbtcBalance,
        bool goalReached,
        bool canWithdraw,
        uint256 withdrawAvailableAt,
        uint256 totalDepositsUSD,
        bool hasReached101Percent,
        uint256 highestPercentage
    ) {
        UserGoal memory goal = userGoals[_user];
        targetAmount = goal.targetAmount;
        tbtcBalance = goal.tbtcBalance;
        goalReached = goal.goalReached;
        totalDepositsUSD = goal.totalDepositsUSD;
        hasReached101Percent = goal.hasReached101Percent;
        highestPercentage = goal.highestPercentage;
        
        if (goal.tbtcBalance > 0) {
            currentValueUSD = getTBTCValueInUSD(goal.tbtcBalance);
        }
        
        if (goal.withdrawRequestTime > 0) {
            withdrawAvailableAt = goal.withdrawRequestTime + WITHDRAW_DELAY;
            canWithdraw = block.timestamp >= withdrawAvailableAt;
        } else if (goal.goalReached || goal.hasReached101Percent) {
            canWithdraw = true;
        }
    }

    function getCurrentBTCPrice() external view returns (uint256, bool isStale) {
        AggregatorV3Interface priceFeed = AggregatorV3Interface(BTC_USD_FEED);
        try priceFeed.latestRoundData() returns (
            uint80,
            int256 price,
            uint256,
            uint256 updatedAt,
            uint80
        ) {
            isStale = block.timestamp > updatedAt + 3600; // Считаем устаревшим после 1 часа
            return (uint256(price), isStale);
        } catch {
            return (0, true);
        }
    }

    function getMinTBTCOut(address _stablecoin, uint256 _amount) external view returns (uint256) {
        uint256 founderFee = _amount * DEPOSIT_FEE_BPS / 10000;
        uint256 amountAfterFee = _amount - founderFee;
        uint256 expectedOutput = getExpectedTBTCAmount(_stablecoin, amountAfterFee);
        uint256 decimals = getTokenDecimals(_stablecoin);
        uint256 amountInUSD = _amount * 1e6 / (10 ** decimals);
        uint256 slippageBps = calculateDynamicSlippage(amountInUSD);
        return expectedOutput * (10000 - slippageBps) / 10000;
    }

    function getContractStats() external view returns (
        uint256 totalTBTC,
        uint256 totalUSDDeposited,
        uint256 currentTotalValueUSD,
        bool emergencyMode,
        uint256 lastOracleUpdateTime,
        uint256 cascadeQueueLength,
        bool cascadeIsPaused
    ) {
        totalTBTC = totalTBTCInContract;
        totalUSDDeposited = totalDepositsInUSD;
        currentTotalValueUSD = isEmergencyMode() ? totalDepositsInUSD : getTBTCValueInUSD(totalTBTCInContract);
        emergencyMode = isEmergencyMode();
        lastOracleUpdateTime = lastOracleUpdate;
        cascadeQueueLength = cascadeQueue.length;
        cascadeIsPaused = cascadePaused;
    }

    // Get cascade queue status
    function getCascadeQueueStatus() external view returns (
        uint256 queueLength,
        address[] memory next25Users,
        bool isPaused,
        uint256 totalProcessed
    ) {
        queueLength = cascadeQueue.length;
        isPaused = cascadePaused;
        totalProcessed = cascadeProcessedCount;
        
        uint256 toReturn = queueLength > 25 ? 25 : queueLength;
        next25Users = new address[](toReturn);
        
        for (uint256 i = 0; i < toReturn; i++) {
            next25Users[i] = cascadeQueue[i];
        }
    }

    // Check if user is in cascade queue
    function isUserInCascadeQueue(address _user) external view returns (bool inQueue, uint256 position) {
        inQueue = inCascadeQueue[_user];
        if (inQueue) {
            for (uint256 i = 0; i < cascadeQueue.length; i++) {
                if (cascadeQueue[i] == _user) {
                    position = i + 1; // 1-indexed for user display
                    break;
                }
            }
        }
    }

    // Calculate withdrawal amounts for a user
    function getWithdrawalAmounts(address _user) external view returns (
        uint256 userAmount,
        uint256 founderAmount,
        bool eligibleForCascadeBonus
    ) {
        UserGoal memory goal = userGoals[_user];
        if (!goal.hasActiveGoal || goal.tbtcBalance == 0) {
            return (0, 0, false);
        }

        uint256 currentValueUSD = getTBTCValueInUSD(goal.tbtcBalance);
        uint256 currentPercentage = currentValueUSD * 10000 / goal.targetAmount;
        eligibleForCascadeBonus = currentPercentage >= CASCADE_THRESHOLD_BPS;

        // Simulate swap to get expected amounts
        uint256 expectedStablecoin = getExpectedStablecoinAmount(goal.lastDepositToken, goal.tbtcBalance);
        uint256 decimals = getTokenDecimals(goal.lastDepositToken);
        uint256 targetInToken = goal.targetAmount * (10 ** decimals) / 1e6;

        if (expectedStablecoin >= targetInToken) {
            userAmount = targetInToken;
            founderAmount = expectedStablecoin - targetInToken;
            
            if (eligibleForCascadeBonus && !cascadePaused) {
                uint256 bonus = targetInToken * CASCADE_BONUS_BPS / 10000;
                if (founderAmount >= bonus) {
                    userAmount += bonus;
                    founderAmount -= bonus;
                } else {
                    userAmount += founderAmount;
                    founderAmount = 0;
                }
            }
        } else {
            // Price dropped scenario
            uint256 feeAmount = expectedStablecoin * GOAL_FEE_BPS / 10000;
            userAmount = expectedStablecoin - feeAmount;
            founderAmount = feeAmount;
        }
    }
}